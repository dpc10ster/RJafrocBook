# Optimal operating point on FROC {#optim-op-point}

---
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: R/learn/my_header.tex
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval.after = "fig.cap"
)

library(RJafroc)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(abind)
library(here)
library(dplyr)
```

## Introduction {#optim-op-point-intro}
Algorithm developers are familiar with this problem: given a CAD system that yields mark-rating data, where the ratings are on a continuous scale (often termed *malignancy index* and the continuous ratings are available to the CAD algorithm designer), how does one select an optimal reporting threshold? Only mark-rating data with ratings exceeding the optimal threshold are to be displayed to the radiologist.

* From the previous chapter it is evident that performance depends of $\zeta_1$, see \@ref(froc-vs-wafroc-peformance-depends-on-zeta1).

* It is taken as an axiomatic truth that *the optimal reporting threshold $\zeta_{\text{max}}$ is that value of $\zeta_1$ that maximizes the AUC under the wAFROC*.  

* This chapter examines the effect of changing the reporting threshold $\zeta_1$ on the wAFROC AUC, with the object of determining the value that maximizes the AUC.

```{r do_one_mu, echo=FALSE}
do_one_mu <- function(zeta1Arr, fomArray, mu, lambda, nu, K1, K2, Lk2, seed) {


  for (i in 1:length(zeta1Arr)) {
    froc1 <- SimulateFrocDataset (
      mu = mu,
      lambda = lambda,
      nu = nu,
      zeta1 = zeta1Arr[i],
      I = 1,
      J = 1,
      K1 = K1,
      K2 = K2,
      perCase = Lk2,
      seed = seed)

    fomArray[i] <- as.numeric(UtilFigureOfMerit(froc1, FOM = "wAFROC"))
  }
  myData <- data.frame(zeta1 = zeta1Arr, AUC = fomArray)
  p <- ggplot2::ggplot(myData, aes(x = zeta1, y = AUC)) + geom_line()
  zetaMax <- zeta1Arr[which.max(fomArray)]
  return(list(
    p = p,
    zetaMax = zetaMax
  ))
}
```

## Methods {#optim-op-point-methods}
The aim is determine the optimal operating point on an FROC. Two values of the $\lambda$ parameter are considered: $\lambda = 10$ and $\lambda = 1$. The first value would characterize a CAD system that generates about 10 times the number of latent NL marks as an expert radiologist, while the second value would characterize a CAD system that generates about the same number of latent NL marks as an expert radiologist. The $\nu$ parameter is kept at the same, namely $\nu = 1$. Four values of the $\mu$ parameter are considered: `r c(1, 1.5, 2, 2.5)`. All else being equal, performance is expected to improve with increasing $\mu$. For each $\mu$ one scans $\zeta_1$, repeating the simulations and AUC and other computations for each value of $\zeta_1$. One determines that value of $\zeta_1$ that maximizes AUC; this is denoted $\zeta_{\text{max}}$. Finally, using the optimal $\zeta_1$ one calculates the corresponding (NLF,LLF) values, i.e., *the optimal operating point on the FROC* and the wAFROC AUC. A large number of cases is used, namely the number of non-diseased cases is $K_1 = 5000$ and the number of diseased cases is $K_2 = 7000$. This minimizes sampling variability while not requiring excessive computation times.

### Simulations for $\lambda = 10$

```{r maxFomArr_10, cache = TRUE, echo=FALSE}
# determine plotArr[[1,]], zetaMaxArr[1,] and maxFomArr[1,]
lambda <- 10
nu <- 1
mu_arr <- c(1, 1.5, 2, 2.5)
maxFomArr <- array(dim = c(2,length(mu_arr)))
zetaMaxArr <- array(dim = c(2, length(mu_arr)))
plotArr <- array(list(), dim = c(2, length(mu_arr)))
K1 <- 5000
K2 <- 7000
Lmax <- 2
seed <- 1
set.seed(seed)
Lk2 <- floor(runif(K2, 1, Lmax + 1))

for (i in 1:length(mu_arr)) {
  if (i == 1) zeta1Arr <- seq(1.5,3.5,0.05) else zeta1Arr <- seq(0.5,2.5,0.1)
  fomArray <- array(dim = length(zeta1Arr))
  x <- do_one_mu (zeta1Arr, fomArray, mu_arr[i], lambda, nu, K1, K2, Lk2, seed)
  plotArr[[1,i]] <- x$p + ggtitle(paste0("mu = ", as.character(mu_arr[i]), ", zetaMax = ",  as.character(x$zetaMax)))
  zetaMaxArr[1,i] <- x$zetaMax
  froc1 <- SimulateFrocDataset (
    mu = mu_arr[i],
    lambda = lambda,
    nu = nu,
    zeta1 = x$zetaMax,
    I = 1,
    J = 1,
    K1 = K1,
    K2 = K2,
    perCase = Lk2,
    seed = seed)
  maxFomArr[1,i] <- as.numeric(UtilFigureOfMerit(froc1, FOM = "wAFROC"))
}
```


```{r optim-op-point-plot5, fig.cap="Variation of AUC vs. $\\zeta_1$ for $\\lambda = 10$; AUC is the wAFROC AUC. The plots are labeled by the value of $\\mu$ and zetaMax (i.e., $\\zeta_{\\text{max}}$, the value of $\\zeta_1$ that maximizes AUC).", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1,1]],plotArr[[1,2]],plotArr[[1,3]],plotArr[[1,4]], nrow = 2, ncol = 2)
```


Fig. \@ref(fig:optim-op-point-plot5) corresponding to $\lambda = 10$ has four panels showing the variation of wAFROC AUC with $\zeta_1$. Each panel is labeled by the values of $\mu$ and  $\zeta_{\text{max}}$. For example, the panel labeled `mu = 1.5, zetaMax = 1.9` shows that AUC has a maximum at $\zeta_1 = 1.9$. For $\mu = 1$ the maximum is at the top of a broad plateau, but for higher values the maximum is better defined.


### Simulations for $\lambda = 1$

```{r maxFomArr_01, cache = TRUE, echo=FALSE}
# determine plotArr[[2,]], zetaMaxArr[2,] and maxFomArr[2,]
lambda <- 1
nu <- 1
K1 <- 5000
K2 <- 7000
Lmax <- 2
seed <- 1
set.seed(seed)
Lk2 <- floor(runif(K2, 1, Lmax + 1))

for (i in 1:length(mu_arr)) {
  zeta1Arr <- seq(-1,1,0.05)
  fomArray <- array(dim = length(zeta1Arr))
  x <- do_one_mu (zeta1Arr, fomArray, mu_arr[i], lambda, nu, K1, K2, Lk2, seed)
  plotArr[[2,i]] <- x$p + ggtitle(paste0("mu = ", as.character(mu_arr[i]), ", zetaMax = ",  as.character(x$zetaMax)))
  zetaMaxArr[2,i] <- x$zetaMax
  froc1 <- SimulateFrocDataset (
    mu = mu_arr[i],
    lambda = lambda,
    nu = nu,
    zeta1 = x$zetaMax,
    I = 1,
    J = 1,
    K1 = K1,
    K2 = K2,
    perCase = Lk2,
    seed = seed)
  maxFomArr[2,i] <- as.numeric(UtilFigureOfMerit(froc1, FOM = "wAFROC"))
}
```



```{r optim-op-point-plot6, fig.cap="Variation of AUC vs. $\\zeta_1$ for $\\lambda = 1$.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[2,1]],plotArr[[2,2]],plotArr[[2,3]],plotArr[[2,4]], nrow = 2, ncol = 2)
```

Fig. \@ref(fig:optim-op-point-plot6) corresponds to $\lambda = 1$ and employs a similar labeling scheme as Fig. \@ref(fig:optim-op-point-plot5). For example, the panel labeled `mu = 1, zetaMax = 0.4` shows that AUC has a maximum at $\zeta_1 = 0.4$. For each maximum the optimal operating point on the FROC is determined as well as the wAFROC AUCs.



```{r do_one_froc, echo=FALSE}
do_one_froc <- function(mu, lambda, nu, zeta1, K1, K2, Lk2, seed) {

  froc <- SimulateFrocDataset (
    mu = mu,
    lambda = lambda,
    nu = nu,
    zeta1 = zeta1,
    I = 1,
    J = 1,
    K1 = K1,
    K2 = K2,
    perCase = Lk2,
    seed = seed)

  froc <- PlotEmpiricalOperatingCharacteristics(
    froc,
    trts= 1,
    rdrs = 1,
    opChType = "FROC", maxDiscrete = 25)

  return(froc)
}
```



```{r detOptOpPt here, cache = TRUE, echo=FALSE}
# determine optOpPt here

lambdaArr <- c(10,1)
nu <- 1
#mu_arr <- c(1, 1.5, 2, 2.5) #already defined above
#zetaMaxArr                  #already defined above
plotArr <- array(list(), dim = c(2,length(mu_arr)))
K1 <- 5000
K2 <- 7000
Lmax <- 2
seed <- 1
set.seed(seed)
Lk2 <- floor(runif(K2, 1, Lmax + 1))

 # indices: lambda, nlf/llf, 4-values of mu
optOpPt1 <- optOpPt <- array(dim = c(2, 2, 4))

for (j in 1:2) {
  for (i in 1:length(mu_arr)) {
    x <- do_one_froc (mu_arr[i],
                      lambdaArr[j],
                      nu,
                      zeta1 = zetaMaxArr[j,i],
                      K1,
                      K2,
                      Lk2,
                      seed)
    # following are empirical end-points
    optOpPt1[j,1,i] <- max(x$Points$genAbscissa)
    optOpPt1[j,2,i] <- max(x$Points$genOrdinate)
    physicalValues <- UtilIntrinsic2PhysicalRSM(mu_arr[i], lambdaArr[j], nu)
    # following are predicted end-points
    optOpPt[j,1,i] <- physicalValues$lambdaP*pnorm(-zetaMaxArr[j,i])
    optOpPt[j,2,i] <- physicalValues$nuP*pnorm(mu_arr[i]-zetaMaxArr[j,i])
  }
}
```



```{r useOptOpPt, cache = TRUE, echo=FALSE}

# use optOpPt here
# generate plotArr

lambdaArr <- c(10,1)
nu <- 1
# following are coordinates of extended plots
optOpPt2 <- array(dim = c(2, 2, 4))
# optOpPt defined above
#mu_arr <- c(1, 1.5, 2, 2.5) #already defined above
#zetaMaxArr                  #already defined above
plotArr <- array(list(), dim = c(2,length(mu_arr)))
K1 <- 5000
K2 <- 7000
Lmax <- 2
seed <- 1
set.seed(seed)
Lk2 <- floor(runif(K2, 1, Lmax + 1))

correction <- array(0.5, dim = c(2, 4))

for (j in 1:2) {
  for (i in 1:length(mu_arr)) {
    x <- do_one_froc (
      mu_arr[i],
      lambdaArr[j],
      nu,
      # to show a fuller extent of the plot
      zeta1 = zetaMaxArr[j,i] - correction[j,i],
      K1,
      K2,
      Lk2,
      seed)

    plotArr[[j,i]] <- x$Plot +
      geom_vline(
        xintercept =
          optOpPt[j,1,i], color = "red")  +
      ggtitle(
        paste0(
          as.character(lambdaArr[j]),
          "-",
          as.character(mu_arr[i])))

    optOpPt2[j,1,i] <- max(x$Points$genAbscissa)
    optOpPt2[j,2,i] <- max(x$Points$genOrdinate)
  }
}
```



```{r optim-op-point-cad-optim-zeta1, echo=FALSE}
x1 <- as.data.frame(rbind(t(maxFomArr[1,]), t(optOpPt[1,1,]), t(optOpPt[1,2,])))
x2 <- as.data.frame(rbind(t(maxFomArr[2,]), t(optOpPt[2,1,]), t(optOpPt[2,2,])))
x12 <- rbind(x1, x2)
x12 <- cbind(c("AUC10", "NLF10", "LLF10", "AUC01", "NLF01", "LLF01"), x12)
colnames(x12) <- c("measure", paste0("mu", as.character(mu_arr)))
y <- c("AUC10", "AUC01", "NLF10", "LLF10", "NLF01", "LLF01")
x12 %>% slice(match(y, measure)) -> xFinal
```


### Summary of simulations and comments {#optim-op-point-comments-threshold-optimization}


```{r optim-op-point-cad-optim-table, echo=FALSE}
knitr::kable(xFinal, digits = 5, caption = "Summary of optimal threshold values: \"measure\" refers to a performance measure, \"mu1\" refers to $\\mu = 1$, etc. The row labels are as follows: AUC10 is the wAFROC AUC for lambda = 10, AUC01 is the wAFROC AUC for $\\lambda = 1$, NLF10 is NLF for $\\lambda = 10$, ..., LLF01 is LLF for $\\lambda = 1$.", escape = FALSE)
```

Table \@ref(tab:optim-op-point-cad-optim-table) summarizes the results of the simulations. In this table the first two rows compare the AUCs for $\lambda=10$ and $\lambda=1$ for the four values of $\mu$. The next two rows show the operating point (NLF, LLF) for $\lambda = 10$ for the four values of $\mu$ and the final two rows are the operating point for $\lambda = 1$ for the four values of $\mu$. The following trends are evident.

* All else being equal, AUC increases with increasing $\mu$. Increasing the separation of the two unit variance normal distributions that determine the ratings of NLs and LLs leads to higher performance
* All else being equal, AUC increases with decreasing $\lambda$. Decreasing the propensity of the observer to generate NLs leads to increasing performance.
* For each value of $\lambda$ optimal LLF increases with increasing $\mu$.
* For $\lambda = 10$ optimal NLF increases with increasing $\mu$.
* For $\lambda = 1$ optimal NLF *peaks* around $\mu = 1.5$.

All of these observations make intuitive sense except, perhaps, that for NLF01. To understand the peaking behavior it is necessary to examine the FROC curves corresponding to the eight -- two $\lambda$ values times four $\mu$ values -- combinations of parameters. In the following eight plots, each labeled by the appropriate $\lambda-\mu$ combination, the optimal value of NLF, corresponding to $\zeta_1 = \zeta_{\text{max}}$, is shown as a red vertical line.

```{r optim-op-point-plot7a, fig.cap="FROC plots: the plot labeled 10-1 is for $\\lambda = 10$ and $\\mu = 1$, and that labeled 10-1.5 is for $\\lambda = 10$ and $\\mu = 1.5$.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[1,1]], plotArr[[1,2]], nrow = 1, ncol = 2)
```             

#### Explanations {#optim-op-point-optim-threshold-explanations}

* In Fig. \@ref(fig:optim-op-point-plot7b) and the plot labeled **10-1**: the vertical red line is at NLF = `r optOpPt[1,1,1]`. The predicted end-point for the curve is (NLF = `r optOpPt[1,1,1]`, LLF = `r optOpPt[1,2,1]`) while the empirical end-point is (NLF = `r optOpPt1[1,1,1]`, LLF = `r optOpPt1[1,2,1]`) and the extended curve (defined below) ends at (NLF = `r optOpPt2[1,1,1]`, LLF = `r optOpPt2[1,2,1]`). In the plot labeled **10-1.5**: The vertical red line is at NLF = `r optOpPt[1,1,2]`. The predicted end-point for the curve is (NLF = `r optOpPt[1,1,2]`, LLF = `r optOpPt[1,2,2]`) while the empirical end-point is (NLF = `r optOpPt1[1,1,2]`, LLF = `r optOpPt1[1,2,2]`) and the extended curve ends at (NLF = `r optOpPt2[1,1,2]`, LLF = `r optOpPt2[1,2,2]`).

* In Fig. \@ref(fig:optim-op-point-plot7a) the plot labeled **10-1** is the *extended* FROC curve for $\lambda = 10$ and $\mu = 1$.
* Meaning of *extended*: due to sampling effects the predicted end-point will not, in general, coincide with the *empirical* end-point, but will be near it. In order to show a fuller extent of the FROC curve it is necessary to *extend* the observed curve beyond the predicted end-point. This was done by setting $\zeta_1$ = $\zeta_{\text{max}} - 0.5$, which has the effect of letting the curve run a little bit further to the right. As a concrete example the predicted end-point for the curve in question is (NLF = `r optOpPt[1,1,1]`, LLF = `r optOpPt[1,2,1]`) while the empirical end-point is (NLF = `r optOpPt1[1,1,1]`, LLF = `r optOpPt1[1,2,1]`) and the extended curve ends at (NLF = `r optOpPt2[1,1,1]`, LLF = `r optOpPt2[1,2,1]`).
* The vertical red line is drawn at the *predicted* optimal NLF corresponding to $\zeta_{\text{max}}$ for this parameter combination, not the *empirical* NLF.  
* In Fig. \@ref(fig:optim-op-point-plot7a) panel labeled 10-1, AUC performance is quite low. In fact AUC = `r maxFomArr[1,1]`. The optimal operating point of the algorithm is actually rather close to the origin, specifically NLF = `r optOpPt[1,1,1]` and LLF = `r optOpPt[1,2,1]`.
* Since algorithm performance is so poor, the sensible choice for the algorithm designer is to only show those marks that have, according to the algorithm, very high confidence level for being right (note that an operating point near the origin corresponds to a high value of $\zeta$).
* For higher values of $\mu$ shown in Fig. \@ref(fig:optim-op-point-plot7a) -- e.g., the plots labeled 10-1.5, 10-2 and 10-2.5 -- AUC performance progressively increases. It now makes sense to show marks with lower confidence levels corresponding to moving up the FROC curve. While it is true that one is also showing more NLs, the increase in the number of LLs shown is enough to compensate. This trend is seen to be true for all operating points listed in the third and fourth rows of Table \@ref(tab:optim-op-point-cad-optim-table).
* It remains to explain the seemingly anomalous behavior seen in the fifth row of Table \@ref(tab:optim-op-point-cad-optim-table) - NLF shows a peak at $\mu = 1.5$ as a function of $\mu$ and thereafter NLF decreases. The relevant FROC curve is shown in Fig. \@ref(fig:optim-op-point-plot7c), panel labeled 1-1.5. The basic reason is that as $\mu$ increases, the end-point of the FROC keeps moving upwards and to the left (approaching NLF = 0 and LLF = 1 in the limit of infinite $\mu$). Because of this effect the expected increase in NLF seen in the third row of the table is terminated - one literally runs out of FROC curve to move up on. Another way of explaining this is that in In Fig. \@ref(fig:optim-op-point-plot7a) the true end-point, i.e., that corresponding to $\zeta_1 = -\infty$, is much further to the right, than in Fig. \@ref(fig:optim-op-point-plot7b). This allows NLF to keep increasing in Fig. \@ref(fig:optim-op-point-plot7a) but not in Fig. \@ref(fig:optim-op-point-plot7b).



```{r optim-op-point-plot7b, fig.cap="FROC plots: the plot labeled 10-2 is for $\\lambda = 10$ and $\\mu = 2$ and that labeled 10-2.5 is for $\\lambda = 10$ and $\\mu = 2.5$.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[1,3]], plotArr[[1,4]], nrow = 1, ncol = 2)
```             

* In Fig. \@ref(fig:optim-op-point-plot7b) and the plot labeled **10-2**: The vertical red line is at NLF = `r optOpPt[1,1,3]`. The predicted end-point for the curve is (NLF = `r optOpPt[1,1,3]`, LLF = `r optOpPt[1,2,3]`) while the empirical end-point is (NLF = `r optOpPt1[1,1,3]`, LLF = `r optOpPt1[1,2,3]`) and the extended curve ends at (NLF = `r optOpPt2[1,1,3]`, LLF = `r optOpPt2[1,2,3]`). In the plot labeled **10-2.5**: The vertical red line is at NLF = `r optOpPt[1,1,4]`. The predicted end-point for the curve is (NLF = `r optOpPt[1,1,4]`, LLF = `r optOpPt[1,2,4]`) while the empirical end-point is (NLF = `r optOpPt1[1,1,4]`, LLF = `r optOpPt1[1,2,4]`) and the extended curve ends at (NLF = `r optOpPt2[1,1,4]`, LLF = `r optOpPt2[1,2,4]`).



```{r optim-op-point-plot7c, fig.cap="FROC plots: the plot labeled 1-1 is for $\\lambda = 1$ and $\\mu = 1$ and that labeled 10-1.5 is for $\\lambda = 1$ and $\\mu = 1.5$.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[2,1]], plotArr[[2,2]], nrow = 1, ncol = 2)
```             

* In Fig. \@ref(fig:optim-op-point-plot7c), the panel labeled **1-1**: The vertical red line is at NLF = `r optOpPt[2,1,1]`. The predicted end-point for the curve is (NLF = `r optOpPt[2,1,1]`, LLF = `r optOpPt[2,2,1]`) while the empirical end-point is (NLF = `r optOpPt1[2,1,1]`, LLF = `r optOpPt1[2,2,1]`) and the extended curve ends at (NLF = `r optOpPt2[2,1,1]`, LLF = `r optOpPt2[2,2,1]`). In the plot labeled **10-1.5**: The vertical red line is at NLF = `r optOpPt[2,1,2]`. The predicted end-point for the curve is (NLF = `r optOpPt[2,1,2]`, LLF = `r optOpPt[2,2,2]`) while the empirical end-point is (NLF = `r optOpPt1[2,1,2]`, LLF = `r optOpPt1[2,2,2]`) and the extended curve ends at (NLF = `r optOpPt2[2,1,2]`, LLF = `r optOpPt2[2,2,2]`).




```{r optim-op-point-plot7d, fig.cap="FROC plots: the plot labeled 1-2 is for $\\lambda = 1$ and $\\mu = 2$ and that labeled 1-2.5 is for $\\lambda = 1$ and $\\mu = 2.5$.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[2,3]], plotArr[[2,4]], nrow = 1, ncol = 2)
```             

* In Fig. \@ref(fig:optim-op-point-plot7d), the panel labeled **1-2**: The vertical red line is at NLF = `r optOpPt[2,1,3]`. The predicted end-point for the curve is (NLF = `r optOpPt[2,1,3]`, LLF = `r optOpPt[2,2,3]`) while the empirical end-point is (NLF = `r optOpPt1[2,1,3]`, LLF = `r optOpPt1[2,2,3]`) and the extended curve ends at (NLF = `r optOpPt2[2,1,3]`, LLF = `r optOpPt2[2,2,3]`). In the plot labeled **10-2.5**: The vertical red line is at NLF = `r optOpPt[2,1,4]`. The predicted end-point for the curve is (NLF = `r optOpPt[2,1,4]`, LLF = `r optOpPt[2,2,4]`) while the empirical end-point is (NLF = `r optOpPt1[2,1,4]`, LLF = `r optOpPt1[2,2,4]`) and the extended curve ends at (NLF = `r optOpPt2[2,1,4]`, LLF = `r optOpPt2[2,2,4]`).




## Discussion {#optim-op-point-Discussion}

## References {#optim-op-point-references}
