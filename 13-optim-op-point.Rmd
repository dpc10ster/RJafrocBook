# Optimal operating point on FROC {#optim-op-point}

```
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: R/learn/my_header.tex
header-includes:
   - \usepackage[justification=raggedright,labelfont=bf,singlelinecheck=false]{caption}
  md_document:
    preserve_yaml: false
```

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval.after = "fig.cap"
)

library(RJafroc)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(abind)
library(here)
library(dplyr)
```

## Introduction {#optim-op-point-intro}
Algorithm developers are familiar with this problem: given a CAD system that yields mark-rating data, where the ratings are on a continuous scale (often termed *malignancy index* and the continuous ratings are available to the CAD algorithm designer), how does one select an optimal reporting threshold? Only mark-rating data with ratings exceeding the optimal threshold are to be displayed to the radiologist. 

* From the previous chapter it is evident that performance depends of $\zeta_1$, see \@ref(froc-vs-wafroc-peformance-depends-on-zeta1).

* It is taken as an axiomatic truth that *the optimal reporting threshold $\zeta_1$ is that value that maximizes the AUC under the wAFROC*. 

* This chapter examines the effect of changing the reporting threshold $\zeta_1$ on the wAFROC AUC, with the object of determining the value that maximizes the AUC. 

```{r do_one_mu, echo=FALSE}
do_one_mu <- function(zeta1Arr, fomArray, mu, lambda, nu, K1, K2, Lk2, seed) {
  
  
  for (i in 1:length(zeta1Arr)) {
    froc1 <- SimulateFrocDataset (
      mu = mu,
      lambda = lambda,
      nu = nu,
      zeta1 = zeta1Arr[i],
      I = 1,
      J = 1,
      K1 = K1,
      K2 = K2,
      perCase = Lk2,
      seed = seed)
    
    fomArray[i] <- as.numeric(UtilFigureOfMerit(froc1, FOM = "wAFROC"))
  }
  myData <- data.frame(zeta1 = zeta1Arr, AUC = fomArray)
  p <- ggplot2::ggplot(myData, aes(x = zeta1, y = AUC)) + geom_line()
  zetaMax <- zeta1Arr[which.max(fomArray)]
  return(list(
    p = p,
    zetaMax = zetaMax
  ))
}
```

## The optimal operating point on the FROC
Two values of the $\lambda$ parameter are considered: $\lambda = 10$ and $\lambda = 1$. The first value would characterize a CAD system that generates about 10 times the number of latent NL marks as an expert radiologist, while the second value would characterize a CAD system that generates about the same number of latent NL marks as an expert radiologist. The $\nu$ parameter is kept at the same, namely $\nu = 1$. Four values of the $\mu$ parameter are considered: `r c(1, 1.5, 2, 2.5)`. All else being equal, performance is expected to improve with increasing $\mu$. For each $\mu$ one scans $\zeta_1$, repeating the simulations and AUC computations for each value of $\zeta_1$. One determines that value of $\zeta_1$ that maximizes AUC; this is denoted $\zeta_{\text{max}}$. Finally, using the optimal $\zeta_1$ one calculates the corresponding (NLF,LLF) values, i.e., *the optimal operating point on the FROC*. To minimize sampling variability, a large number of cases is used, namely the number of non-diseased cases is $K_1 = 5000$ and the number of diseased cases is $K_2 = 7000$. 

### Simulations for $\lambda = 10$

```{r maxFomArr_10, cache = TRUE, echo=FALSE}
# determine zetaMaxArr[1,i] and maxFomArr_10
lambda <- 10 
nu <- 1
mu_arr <- c(1, 1.5, 2, 2.5)
maxFomArr_10 <- array(dim = length(mu_arr))
zetaMaxArr <- array(dim = c(2, length(mu_arr)))
plotArr <- array(list(), length(mu_arr))
K1 <- 5000
K2 <- 7000
Lmax <- 2
seed <- 1
set.seed(seed)
Lk2 <- floor(runif(K2, 1, Lmax + 1))

for (i in 1:length(mu_arr)) {
  if (i == 1) zeta1Arr <- seq(1.5,3.5,0.05) else zeta1Arr <- seq(0.5,2.5,0.1)
  fomArray <- array(dim = length(zeta1Arr))
  x <- do_one_mu (zeta1Arr, fomArray, mu_arr[i], lambda, nu, K1, K2, Lk2, seed)
  plotArr[[i]] <- x$p + ggtitle(paste0("mu = ", as.character(mu_arr[i]), ", zetaMax = ",  as.character(x$zetaMax)))
  zetaMaxArr[1,i] <- x$zetaMax
  froc1 <- SimulateFrocDataset (
    mu = mu_arr[i],
    lambda = lambda,
    nu = nu,
    zeta1 = x$zetaMax,
    I = 1,
    J = 1,
    K1 = K1,
    K2 = K2,
    perCase = Lk2,
    seed = seed)
  maxFomArr_10[i] <- as.numeric(UtilFigureOfMerit(froc1, FOM = "wAFROC"))
}
```


```{r optim-op-point-plot5, fig.cap="Variation of AUC vs. $\\zeta_1$; AUC is the wAFROC AUC. The plots are labeled by the value of $\\mu$ and zetaMax (the value of $\\zeta_1$ that maximizes AUC).", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]],plotArr[[2]],plotArr[[3]],plotArr[[4]], nrow = 2, ncol = 2)
```


Fig. \@ref(fig:optim-op-point-plot5) corresponding to $\lambda = 10$ has four panels showing the variation of wAFROC AUC with $\zeta_1$. Each panel is labeled by the values of $\mu$ and  $\zeta_{\text{max}}$. For example, the panel labeled `mu = 1.5, zetaMax = 1.9` shows that AUC has a maximum at $\zeta_1 = 1.9$. For $\mu = 1$ the maximum is at the top of a broad plateau, but for higher values the maximum is better defined. 


### Simulations for $\lambda = 1$

```{r maxFomArr_01, cache = TRUE, echo=FALSE}
# determine zetaMaxArr[2,i] and maxFomArr_01

lambda <- 1
nu <- 1
mu_arr <- c(1, 1.5, 2, 2.5)
maxFomArr_01 <- array(dim = length(mu_arr))
plotArr <- array(list(), length(mu_arr))
K1 <- 5000
K2 <- 7000
Lmax <- 2
seed <- 1
set.seed(seed)
Lk2 <- floor(runif(K2, 1, Lmax + 1))

for (i in 1:length(mu_arr)) {
  zeta1Arr <- seq(-1,1,0.05)
  fomArray <- array(dim = length(zeta1Arr))
  x <- do_one_mu (zeta1Arr, fomArray, mu_arr[i], lambda, nu, K1, K2, Lk2, seed)
  plotArr[[i]] <- x$p + ggtitle(paste0("mu = ", as.character(mu_arr[i]), ", zetaMax = ",  as.character(x$zetaMax)))
  zetaMaxArr[2,i] <- x$zetaMax
  froc1 <- SimulateFrocDataset (
    mu = mu_arr[i],
    lambda = lambda,
    nu = nu,
    zeta1 = x$zetaMax,
    I = 1,
    J = 1,
    K1 = K1,
    K2 = K2,
    perCase = Lk2,
    seed = seed)
  maxFomArr_01[i] <- as.numeric(UtilFigureOfMerit(froc1, FOM = "wAFROC"))
}
```



```{r optim-op-point-plot6, fig.cap="Variation of AUC vs. $\\zeta_1$; AUC is the wAFROC AUC. The plots are labeled by the value of $\\mu$ and zetaMax (the value of $\\zeta_1$ that maximizes AUC).", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]],plotArr[[2]],plotArr[[3]],plotArr[[4]], nrow = 2, ncol = 2)
```

Fig. \@ref(fig:optim-op-point-plot6) corresponding to $\lambda = 1$ and employs a similar labeling scheme. For example, the panel labeled `mu = 1, zetaMax = 0.4` shows that AUC has a maximum at $\zeta_1 = 0.4$. 



```{r do_one_froc, echo=FALSE}
do_one_froc <- function(mu, lambda, nu, zeta1, K1, K2, Lk2, seed) {
  
  froc <- SimulateFrocDataset (
    mu = mu,
    lambda = lambda,
    nu = nu,
    zeta1 = zeta1,
    I = 1,
    J = 1,
    K1 = K1,
    K2 = K2,
    perCase = Lk2,
    seed = seed)
  
  froc <- PlotEmpiricalOperatingCharacteristics(
    froc,
    trts= 1,
    rdrs = 1,
    opChType = "FROC", maxDiscrete = 25)
  
  return(froc)
}
```



```{r detOptOpPt here, cache = TRUE, echo=FALSE}
# determine optOpPt here

lambdaArr <- c(10,1) 
nu <- 1
#mu_arr <- c(1, 1.5, 2, 2.5) #already defined above
#zetaMaxArr                  #already defined above
plotArr <- array(list(), dim = c(2,length(mu_arr)))
K1 <- 5000
K2 <- 7000
Lmax <- 2
seed <- 1
set.seed(seed)
Lk2 <- floor(runif(K2, 1, Lmax + 1))

 # lambda, nlf/llf, 4-values of mu
optOpPt <- array(dim = c(2, 2, 4))

for (j in 1:2) {
  for (i in 1:length(mu_arr)) {
    x <- do_one_froc (mu_arr[i], 
                      lambdaArr[j], 
                      nu,
                      zeta1 = zetaMaxArr[j,i],
                      K1, 
                      K2, 
                      Lk2, 
                      seed)
    optOpPt[j,1,i] <- max(x$Points$genAbscissa)
    optOpPt[j,2,i] <- max(x$Points$genOrdinate)
    
  }
  
}
```



```{r useOptOpPt, cache = TRUE, echo=FALSE}
# use optOpPt here
# generate plotArr

lambdaArr <- c(10,1) 
nu <- 1
# optOpPt defined above
#mu_arr <- c(1, 1.5, 2, 2.5) #already defined above
#zetaMaxArr                  #already defined above
plotArr <- array(list(), dim = c(2,length(mu_arr)))
K1 <- 5000
K2 <- 7000
Lmax <- 2
seed <- 1
set.seed(seed)
Lk2 <- floor(runif(K2, 1, Lmax + 1))

correction <- array(0.1, dim = c(2, 4))
correction[2,] <- 0.5

for (j in 1:2) {
  for (i in 1:length(mu_arr)) {
    x <- do_one_froc (
      mu_arr[i], 
      lambdaArr[j], 
      nu,
      # to show a fuller extent of the plot
      zeta1 = zetaMaxArr[j,i] - correction[j,i], 
      K1, 
      K2, 
      Lk2, 
      seed)
    
    plotArr[[j,i]] <- x$Plot + 
      geom_vline(
        xintercept = 
          optOpPt[j,1,i], color = "red")  + 
      ggtitle(
        paste0(
          as.character(lambdaArr[j]),
          "-",
          as.character(mu_arr[i])))
    
  }
}
```



```{r optim-op-point-cad-optim-zeta1, echo=FALSE}
x1 <- as.data.frame(rbind(t(maxFomArr_10), t(optOpPt[1,1,]), t(optOpPt[1,2,])))
x2 <- as.data.frame(rbind(t(maxFomArr_01), t(optOpPt[2,1,]), t(optOpPt[2,2,])))
x12 <- rbind(x1, x2)
x12 <- cbind(c("AUC10", "NLF10", "LLF10", "AUC01", "NLF01", "LLF01"), x12)
colnames(x12) <- c("measure", paste0("muVal", as.character(mu_arr)))
y <- c("AUC10", "AUC01", "NLF10", "LLF10", "NLF01", "LLF01")
x12 %>% slice(match(y, measure)) -> xFinal
```


### Comments {#optim-op-point-comments-threshold-optimization}

```{r optim-op-point-cad-optim-table, echo=FALSE}
knitr::kable(xFinal, digits = 5, caption = "Summary of CAD optimal threshold simulations: \"measure\" refers to a performance measure: AUC, NLF or LLF; the labels are as follows: AUC10 is the wAFROC AUC for lambda = 10, AUC01 is the wAFROC AUC for lambda = 01, NLF10 is NLF for lambda = 1, ..., LLF01 is LLF for lambda = 1.", escape = FALSE)
```

In Table \@ref(tab:optim-op-point-cad-optim-table) the first two rows compare the AUCs, the next two rows show the operating point (NLF, LLF) for $\lambda = 10$ and the final two rows are the operating point for $\lambda = 1$. The following trends are evident.

* All else being equal, AUC increases with increasing $\mu$. Increasing the separation of the two unit variance normal distributions that determine the ratings of NLs and LLs leads to higher performance
* All else being equal, AUC increases with decreasing $\lambda$. Decreasing the propensity of the observer to generate NLs leads to increasing performance. 
* For each value of $\lambda$ optimal LLF increases with increasing $\mu$. 
* For $\lambda = 10$ optimal NLF increases with increasing $\mu$. 
* For $\lambda = 0$ optimal NLF peaks around $\mu = 1.5$. 


```{r optim-op-point-plot7a, fig.cap="The vertical red lines show the locations of the optimal NLFs. The plot labeled 10-1 is the FROC plot for $\\lambda = 10$ and $\\mu = 1$. The plot labeled 10-1.5 is the FROC plot for $\\lambda = 10$ and $\\mu = 1.5$.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[1,1]], plotArr[[1,2]], nrow = 1, ncol = 2)
```             


* In Fig. \@ref(fig:optim-op-point-plot7a) the plot labeled 10-1 is a FROC plot for $\lambda = 10$ and $\mu = 1$; AUC performance is quite low, AUC = `r maxFomArr_10[1]` and the optimal operating point of the algorithm is near the origin, specifically, NLF = `r optOpPt[1,1,1]` and LLF = `r optOpPt[1,2,1]`. If the algorithm is this poor, the sensible choice for the algorithm designer is to only show those marks that have, according to the algorithm, high confidence level for being right (note that an operating point near the origin corresponds to a high value of $\zeta_1$). For higher values of $\mu$ AUC performance increases and it makes sense to then show marks with a somewhat lower confidence level, corresponding to moving up the curve. While it is true that one is possibly showing more NLs, the fraction of LLs increases even more. This trend is seen to be true for all operating points listed in the third and fourth rows of Table \@ref(tab:optim-op-point-cad-optim-table). Performance of the algorithm is very poor and it makes sense to set a high threshold corresponding to a low value of NLF = `r optOpPt[1,1,1]`. The observer is only shown very high confidence level marks. 
* In the plot labeled 10-1.5 the FROC plot is for $\lambda = 10$ and $\mu = 1.5$. Performance is better and it makes sense to set the threshold at a lower value, corresponding to a higher NLF = `r optOpPt[1,1,2]`, and because of the increased algorithm performance it makes sense to show him lower confidence level marks. 

STOP

```{r optim-op-point-plot7b, fig.cap="The vertical red lines show the locations of the optimal NLFs. The plot labeled 10-2 is the FROC plot for $\\lambda = 10$ and $\\mu = 2$. The plot labeled 10-2.5 is FROC plot for $\\lambda = 10$ and $\\mu = 2.5$.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[1,3]], plotArr[[1,4]], nrow = 1, ncol = 2)
```             


Fig. \@ref(fig:optim-op-point-plot7b): Plot labeled 10-1: The vertical red line is at NLF = `r optOpPt[1,1,3]`. Plot labeled 10-1.5: The vertical red line is at NLF = `r optOpPt[1,1,4]`.


```{r optim-op-point-plot7c, fig.cap="The vertical red lines show the locations of the optimal NLFs. The plot labeled 1-1 is the FROC plot for $\\lambda = 1$ and $\\mu = 1$. The plot labeled 10-1.5 is the FROC plot for $\\lambda = 1$ and $\\mu = 1.5$.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[2,1]], plotArr[[2,2]], nrow = 1, ncol = 2)
```             

Fig. \@ref(fig:optim-op-point-plot7c): Plot labeled 1-1: The vertical red line is at NLF = `r optOpPt[2,1,1]`. Plot labeled 1-1.5: The vertical red line is at NLF = `r optOpPt[2,1,2]`.


```{r optim-op-point-plot7d, fig.cap="The vertical red lines show the locations of the optimal NLFs. The plot labeled 1-2 is the FROC plot for $\\lambda = 1$ and $\\mu = 2$. The plot labeled 1-2.5 is the FROC plot for $\\lambda = 1$ and $\\mu = 2.5$.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[2,3]], plotArr[[2,4]], nrow = 1, ncol = 2)
```             

Fig. \@ref(fig:optim-op-point-plot7d): Plot labeled 1-2: The vertical red line is at NLF = `r optOpPt[2,1,3]`. Plot labeled 1-2.5: The vertical red line is at NLF = `r optOpPt[2,1,4]`.



## Discussion {#optim-op-point-Discussion}

## References {#optim-op-point-references}
