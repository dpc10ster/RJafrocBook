# Optimal operating point on FROC {#optim-op-point}

---
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: R/learn/my_header.tex
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval.after = "fig.cap"
)

library(RJafroc)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(abind)
library(dplyr)
```



```{r, echo=FALSE}
OpPtStr <- function(x,y) {
  y <- paste0("(", sprintf("%.3f", x), ", ", sprintf("%.3f", y), ")")
  return(y)
}

simplePrint <- function(x) {
  sprintf("%.3f", x)
}
```



## How much finished {#optim-op-point-how-much-finished}
40%
Major update to 21-optim-op-point.Rmd - need to resolve plots in vary mu


## Introduction {#optim-op-point-intro}

This chapter deals with finding the optimal reporting threshold of an algorithmic observer, such as CAD. We assume that designer level FROC data is available for the algorithm: the data consists of mark-rating pairs, with the continuous-scale ratings extending from low to high values, and a decision needs to be made as to which of these marks, if any, are to be reported to the radiologist. This is a familiar problem faced by a CAD algorithm designer, and to the best of my knowledge, it has not been solved. 

A proposed approach is to set the operating point on the ROC curve such as to maximize the Youden-index. The Youden-index is defined as the sum of sensitivity and specificity minus one. Typically it is maximized at the point that is closest to the (0,1) point on the ROC. However, in practice, CAD manufacturers set a site-specific reporting threshold in consultation with the radiologists who will be using the algorithm. For example, if radiologists are comfortable with more false marks as the price of potentially greater lesion-level sensitivity, the reporting threshold is adjusted downward. At sites where the radiologists are uncomfortable with more false marks being shown, the reporting threshold is adjusted upward.

This chapter describes a method of finding the optimal reporting threshold based on maximizing the AUC under the wAFROC curve. For completeness it is compared to the Youden-index based method.  



## Methods {#optim-op-point-methods}

The RSM (radiological search model) parameters are $\lambda$, $\nu$, $\mu$ and $\zeta_1$. The ROC, FROC and wAFROC curves are completely defined by them. The parameters have the following meanings:

* The $\mu$ parameter is the perceptual signal to noise ratio of lesions measured under location-known-exactly conditions. These have a direct effect on the search mechanism, since, as $\mu$ increases, lesions are more likely to be found and non-diseased regions are less likely to be mistaken for lesions. Higher values of $\mu$ lead to increased overall performance of the algorithm.

* The $\lambda$ parameter determines the number of non-lesion localizations, NLs, per case (location level "false positives"). Lower values lead to fewer NL marks and increased overall performance of the algorithm.

* The $\nu$ parameter determines the probability of a lesion localizations, LLs, (location level "true positives"). Higher values lead to more LL marks.

* The $\zeta_1$ parameter determines if a suspicious region found by the algorithm is actually marked. The higher this value, the fewer the reported marks.


In the following sections each of the first three parameters is varied in turn and the corresponding optimal $\zeta_1$ determined by maximizing one of two figures of merit (FOMs) namely, the wAFROC-AUC and the Youden-index. 


### Functions to be maximized
The functions to be maximized, `wAFROC` and `Youden`, are defined next: 

* wAFROC-AUC is computed by `UtilAnalyticalAucsRSM`. Lines 2 - 19 returns `-wAFROC`, the *negative* of wAFROC-AUC. The negative sign is needed because the `optimize()` function, used later, finds the *minimum* of wAFROC-AUC. The first argument is $\zeta_1$, the variable to be varied to find the maximum. The remaining arguments passed to the function, needed to calculate the FOMs, are $\mu$, $\lambda$, $\nu$, `lesDistr` and `relWeights.` The last two specify the number of lesions per case and their weights. The following code below uses `lesDistr = c(0.5,0.5)`, i.e., half of the diseased cases contain one lesion and the rest contain two lesions, and `relWeights = c(0.5,0.5)`, which specifies equal weights to all lesions.


* The Youden-index is defined as the sum of sensitivity and specificity minus 1. Sensitivity is computed by `RSM_yROC` and specificity by `(1 - RSM_xROC)`. Lines 22 - 42 returns `-Youden`, the *negative* of the Youden-index. 



```{r functions_2be_maximized, echo=TRUE, attr.source = ".numberLines"}

wAFROC <- function (
  zeta1, 
  mu, 
  lambda, 
  nu, 
  lesDistr, 
  relWeights) {
  x <- UtilAnalyticalAucsRSM(
    mu, 
    lambda, 
    nu, zeta1, 
    lesDistr, 
    relWeights)$aucwAFROC
  # return negative of aucwAFROC 
  # (as optimize finds minimum of function)
  return(-x)
  
}


Youden <- function (
  zeta1, 
  mu, 
  lambda, 
  nu, 
  lesDistr, 
  relWeights) {
  # add sensitivity and specificity 
  # and subtract 1, i.e., Youden's index
  x <- RSM_yROC(
    zeta1, 
    mu, 
    lambda, 
    nu, 
    lesDistr) + 
    (1 - RSM_xROC(zeta1, lambda)) - 1
  # return negative of Youden-index 
  # (as optimize finds minimum of function)
  return(-x)
  
}
```


### Vary lambda  {#optim-op-point-vary-lambda}

For $\mu = 2$ and $\nu = 1$ wAFROC-AUC and Youden-index based optimizations were performed for 4 values of $\lambda = 1, 5, 10, 15$. The following quantities were calculated:

* `zetaOptArr`, a [2,4] array, the optimal thresholds $\zeta_1$; 
* `fomMaxArr`, a [2,4] array, the maximized values of the figures of merit, wAFROC-AUC or Youden-index; 
* `rocAucArr`, a [2,4] array, the AUCs under the ROC curves corresponding to optimizations based on wAFROC-AUC or Youden-index;   
* `nlfOptArr`, a [2,4] array, the abscissa of the optimal reporting point on the FROC curve corresponding to optimizations based on wAFROC-AUC or Youden-index;   
* `llfOptArr`, a [2,4] array, the ordinate of the optimal reporting point on the FROC curve corresponding to optimizations based on wAFROC-AUC or Youden-index.   

In each of these arrays the first index `y` denotes whether wAFROC-AUC is being maximized (`y` = 1, see lines 14 - 20) - or if Youden-index is being optimized (`y` = 2, see lines 39 - 45). The second index corresponds to $\lambda$.


```{r optim-op-point-computations-lambda, cache = FALSE, echo=TRUE, attr.source = ".numberLines"}
mu <- 2
nu <- 1
lambdaArr <- c(1,5,10,15)
fomMaxArr <- array(dim = c(2,length(lambdaArr)))
zetaOptArr <- array(dim = c(2,length(lambdaArr)))
rocAucArr <- array(dim = c(2,length(lambdaArr)))
nlfOptArr <- array(dim = c(2,length(lambdaArr)))
llfOptArr <- array(dim = c(2,length(lambdaArr)))
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
for (y in 1:2) {
  for (i in 1:length(lambdaArr)) {
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaArr[i], 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      fomMaxArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaArr[i], 
        nu, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda = lambdaArr[i])
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nu)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaArr[i], 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      fomMaxArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaArr[i], 
        nu, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda = lambdaArr[i])
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, mu, nu)
    } else stop("incorrect y")
  }
}
```



Table \@ref(tab:optim-op-point-table1) summarizes the results. The column labeled "FOM" shows the quantity being maximized, "lambda" corresponds to the 4 values of $\lambda$, "zeta1" is the optimal value of $\zeta_1$ that maximizes FOM, "wAFROC" is the wAFROC-AUC, "ROC" is the AUC under the ROC curve, i.e., ROC-AUC, and "OptOpPt" is the optimal operating point on the FROC curve. 

Focusing on the wAFROC-AUC based optimizations (first four rows of table), it is seen that as $\lambda$ increases:

* The optimal threshold $\zeta_1$ increases;
* wAFROC-AUC decreases;
* ROC-AUC decreases;
* The optimal operating point on the FROC moves to lower LLF values, i.e., lower values of lesion-level "sensitivity".

The $\lambda$ Poisson parameter controls the average number of latent non-lesion localizations (NLs or location-level "false-positives") per case. For example, for $\mu = 2$ and $\lambda = 1$, the average number of latent NLs per case is $\lambda' = \lambda /\mu = 0.5$, i.e., an average of one NL every two non-diseased case. With increasing numbers of NLs it is necessary to increase the reporting threshold in order to not overwhelm the radiologist with NLs, and the price paid is decreasing LLF, as evident in the last column of the table. Overall CAD performance, regardless of how it is measured (i.e., wAFROC-AUC or ROC-AUC), decreases.   

Similar trends are observed for the Youden-index based optimizations (last four rows of table). However, comparing Youden-index based optimizations as a group to wAFROC-AUC based optimizations shows that the former yield higher reporting thresholds, lower wAFROC-AUC, lower ROC-AUC and lower LLF values. 




```{r optim-op-point-table1-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), lambda = lambdaArr, zeta1 = simplePrint(zetaOptArr[1,]), wFROC = simplePrint(fomMaxArr[1,]), ROC = simplePrint(rocAucArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), lambda = lambdaArr, zeta1 = simplePrint(zetaOptArr[2,]), wFROC = simplePrint(fomMaxArr[2,]), ROC = simplePrint(rocAucArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "lambda", "zeta1", "wAFROC", "ROC", "OptOpPt")
```



```{r optim-op-point-table1, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\mu = 2$, $\\nu = 1$ and different values of $\\lambda$.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```



As regards displaying FROC curves with superimposed optimal operating points, one could generate 8 plots, each corresponding to a row of the preceding table, but there is a more efficient method. The FROC curve is defined in terms of the RSM parameters as follows:



\begin{equation}
\left. 
\begin{aligned}
NLF \left ( \zeta, \lambda' \right ) =& \lambda' \Phi \left (-\zeta \right ) \\
LLF\left ( \zeta, \mu, \nu', \overrightarrow{f_L} \right ) =& \nu' \Phi \left ( \mu - \zeta \right ) 
\end{aligned}
\right \}
(\#eq:rsm-froc-predictions)
\end{equation}

Here $\overrightarrow{f_L}$ is the lesion-distribution vector, `c(0.5, 0.5)` in the current example. The *physical* parameters (that determine the FROC) $\lambda'$ and $\nu'$ are related to the *intrinsic* parameters $\mu$, $\lambda$ and $\nu$ by: 

\begin{equation}
\left. 
\begin{aligned}
\lambda' =& \frac{\lambda  }{\mu} \\
\nu' =& 1 - exp\left (-\mu \nu \right ) 
\end{aligned}
\right \}
(\#eq:rsm-intrinsic-physical)
\end{equation}


Since the $\Phi$ function ranges from one to unity, the *four FROC curves for different values of $\lambda$ are scaled versions of a single curve whose x-axis ranges from 0 to 1*. The single curve corresponds to $\lambda' = 1$ and the true curves are obtained by scaling this curve along the x-axis by the appropriate $\lambda'$ factor. With this understanding one can display 4 FROC curves with a single FROC curve where the x-axis is $NLF \left ( \zeta, \lambda' = 1 \right )$. The true FROC curve is defined by:  



\begin{equation}
\left. 
\begin{aligned}
NLF \left ( \zeta, \lambda' \right ) =& \lambda' NLF \left ( \zeta, \lambda' = 1 \right ) \\
LLF\left ( \zeta, \mu, \nu', \overrightarrow{f_L} \right ) =& \nu' \Phi \left ( \mu - \zeta \right ) 
\end{aligned}
\right \}
(\#eq:rsm-froc-predictions2)
\end{equation}




```{r, attr.source = ".numberLines", echo=FALSE}
scaled_froc <- array(list(), dim = 2)
for (y in 1:2) {
  i <- 1 # no need to generate scaled FROC 4 times
  z <- seq(-5,zetaOptArr[y,i]+5,0.1)
  lambdaP <- lambdaArr[i] / mu
  # scale x-axis to range (0,1) by dividing by lambdaP
  xFROC <- RSM_xFROC(z, mu, lambdaArr[i]) / lambdaP
  yFROC <- RSM_yFROC(z, mu, nu)
  df_scaled_froc <- data.frame(
    NLF_scaled = xFROC, 
    LLF = yFROC)
  scaled_froc[[y]] <- ggplot2::ggplot(
    df_scaled_froc, 
    aes(x = NLF_scaled, y = LLF)) + 
    geom_line() +
    scale_x_continuous(limits = c(0,1)) + 
    scale_y_continuous(limits = c(0,1))
  for ( i in 1:length(lambdaArr)) {
    lambdaP <- lambdaArr[i] / mu
    # scale NLF value by dividing 
    # by lambdaP to match scaling of x-axis
    optPt <- data.frame(
      NLF_scaled = nlfOptArr[y,i] / lambdaP, 
      LLF = llfOptArr[y,i])
    scaled_froc[[y]] <- scaled_froc[[y]] + 
      geom_point(data = optPt, color = i)
  }
}
```




```{r optim-op-point-vary-lambda, fig.cap="Left panel: maximized wAFROC AUC was used to find optimal $\\zeta_1$. Right panel: maximized Youden index was used to find optimal $\\zeta_1$. Dot colors: black means $\\lambda = 1$, red means $\\lambda = 5$, green means $\\lambda = 10$ and blue means $\\lambda = 15$.", fig.show='hold', echo=FALSE}
grid.arrange(scaled_froc[[1]], scaled_froc[[2]], ncol = 2)
```


The left panel in \@ref(fig:optim-op-point-vary-lambda) shows the optimal operating points when wAFROC-AUC is maximized. The 4 operating points are color coded as follows:

* The black dot corresponds to $\lambda = 1$, i.e., $\lambda' = 1/2 = 0.5$. In other words, the true FROC is obtained by *shrinking* the plot shown, including the superposed black dot, along the x-axis by a factor of 2.  
* The red dot corresponds to $\lambda' = 2.5$. In other words, the true FROC is obtained by *magnifying* that shown, including the red dot, along the x-axis by a factor of 2.5.   
* The green dot corresponds to $\lambda' = 5$. 
* The blue dot corresponds to $\lambda' = 7.5$.  

These plots illustrate the previous comments, namely, as $\lambda$ increases, *the optimal operating point moves down the scaled curve*.

The right panel shows the optimal operating point when the Youden-index is maximized. It shows the same general features as the previous example but the group of four operating points in the right panel are below-left those in the left panel, representing higher values of optimal $\zeta_1$, i.e., a more stringent criteria. As seen in the preceding table the overly strict critera obtained using Youden-index based optimization, leads to lower overall performance: i.e., lower wAFROC-AUC and lower ROC-AUC.


The FROC curve does not represent true performance. To visualize true performance one compares wAFROC curves.    



```{r, attr.source = ".numberLines", echo=FALSE}
wafroc <- PlotRsmOperatingCharacteristics(
     c(mu,mu),
     lambdaArr[c(1,1)],
     c(nu,nu),
     c(zetaOptArr[1,1], zetaOptArr[2,1]),
     lesDistr,
     relWeights,
     OpChType = "wAFROC",
     legendPosition = "null"
)$wAFROCPlot
```




```{r optim-op-point-vary-lambda-wafroc, fig.cap="wAFROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\\mu = 2$, $\\nu = 1$ and $\\lambda = 1$. The optimal reporting theshold $\\zeta_1$ is determined by the selected FOM. The red curve corresponds to FOM = wAFROC-AUC and the blue curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the wAFROC.", fig.show='hold', echo=FALSE}
grid.arrange(wafroc)
```


Each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table1), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,1])` for the red curve and $\zeta_1$ = `r simplePrint(zetaOptArr[2,1])` for the blue curve. The lower performance represented by the blue curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.



### Vary nu {#optim-op-point-vary-nu}

For $\mu = 2$ and $\lambda= 5$ wAFROC-AUC and Youden-index based optimizations were performed for 4 values of $\nu = 0.1,0.5,1,2$. Table \@ref(tab:optim-op-point-table2) summarizes the results. 




```{r optim-op-point-computations-nu, cache = FALSE, echo=FALSE}
mu <- 2
lambda <- 5
nuArr <- c(0.1,0.5,1,2)
fomMaxArr <- array(dim = c(2,length(nuArr)))
zetaOptArr <- array(dim = c(2,length(nuArr)))
rocAucArr <- array(dim = c(2,length(nuArr)))
nlfOptArr <- array(dim = c(2,length(nuArr)))
llfOptArr <- array(dim = c(2,length(nuArr)))
for (y in 1:2) {
  for (i in 1:length(nuArr)) {
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambda, 
                    nuArr[i], 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      fomMaxArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambda, 
        nuArr[i], 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nuArr[i])
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambda, 
                    nuArr[i], 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      fomMaxArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambda, 
        nuArr[i], 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nu = nuArr[i])
    } else stop("incorrect y")
  }
}
```






```{r optim-op-point-table2-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), nu = nuArr, zeta1 = simplePrint(zetaOptArr[1,]), wFROC = simplePrint(fomMaxArr[1,]), ROC = simplePrint(rocAucArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), nu = nuArr, zeta1 = simplePrint(zetaOptArr[2,]), wFROC = simplePrint(fomMaxArr[2,]), ROC = simplePrint(rocAucArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "nu", "zeta1", "wAFROC", "ROC", "OptOpPt")
```



```{r optim-op-point-table2, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\mu = 2$, $\\lambda = 5$ and different values of $\\nu$.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```


The effect of increasing $\nu$ is to cause the optimal operationg point to move up the FROC curve: it is opposite to the effect of increasing $\lambda$. Focusing on the wAFROC-AUC based optimizations (first four rows of table), it is seen that as $\nu$ increases:

* The optimal threshold $\zeta_1$ decreases, resulting in more marks being reported;
* wAFROC-AUC increases;
* ROC-AUC increases;
* The optimal operating point on the FROC moves to higher LLF values, i.e., higher values of lesion-level "sensitivity".

The $\nu$ binomial parameter controls the average fraction of latent lesion localizations (LLs or "true-positives") per diseased case. For example, for $\mu = 2$ and $\nu = 0.1$, the fraction is $\nu' = 1 - \exp(-\mu \nu) = 0.1813$, i.e., an average of 18 percent of lesions present are seen by CAD at confidence level $ > -\infty$. Overall CAD performance increases with increasing $\nu$.   

Comparing Youden-index based optimizations (last four rows of table) to wAFROC-AUC based optimizations shows that the former yields higher reporting thresholds, lower wAFROC-AUC, lower ROC-AUC and lower LLF values. 




```{r, echo=FALSE}
froc <- array(list(), dim = c(2))
for (y in 1:2) {
  froc[[y]] <- ggplot2::ggplot()
  for ( i in 1:length(nuArr)) {
    z <- seq(-5,zetaOptArr[y,i]+5,0.1)
    xFROC <- RSM_xFROC(z, mu, lambda)
    yFROC <- RSM_yFROC(z, mu, nuArr[i]) 
    df_froc <- data.frame(NLF = xFROC, LLF = yFROC)
    froc[[y]] <- froc[[y]] + 
      geom_line(data = df_froc, aes(x = NLF, y = LLF))
    optPt <- data.frame(
      NLF = nlfOptArr[y,i], 
      LLF = llfOptArr[y,i]) 
    froc[[y]] <- froc[[y]] + 
      geom_point(data = optPt, 
                 aes(x = NLF, y = LLF),  
                 color = i)
  }
}
```




```{r optim-op-point-vary-nu, fig.cap="Left panel: maximized wAFROC-AUC was used to find optimal $\\zeta_1$. Right panel: maximized Youden-index was used to find optimal $\\zeta_1$. Dot colors: black means $\\nu = 0.1$, red means $\\nu = 0.5$, green means $\\nu = 1$ and blue means $\\nu = 2$.", fig.show='hold', echo=FALSE}
grid.arrange(froc[[1]], froc[[2]], ncol = 2)
```


Fig. \@ref(fig:optim-op-point-vary-nu) shows the FROC curves with optimal operating points superimposed. The left panel corresponds to wAFROC-AUC based optimizations while the right panel corresponds to Youden-index based optimizations. These illustrate the previous comments, namely, as $\nu$ increases, *the optimal operating point moves up the FROC curve*.


To visualize true performance one compares wAFROC curves.    



```{r, echo=FALSE}
wafroc <- PlotRsmOperatingCharacteristics(
     c(mu,mu),
     c(lambda,lambda),
     nuArr[c(4,4)],
     c(zetaOptArr[1,4], zetaOptArr[2,4]),
     lesDistr,
     relWeights,
     OpChType = "wAFROC",
     legendPosition = "null"
)$wAFROCPlot
```


```{r optim-op-point-vary-nu-wafroc, fig.cap="wAFROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\\mu = 2$, $\\lambda = 5$ and $\\nu = 2$. The optimal reporting theshold $\\zeta_1$ is determined by the selected FOM. The red curve corresponds to FOM = wAFROC-AUC and the blue curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the wAFROC.", fig.show='hold', echo=FALSE}
grid.arrange(wafroc)
```


Each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table2), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,4])` for the red curve and $\zeta_1$ = `r simplePrint(zetaOptArr[2,4])` for the blue curve. The lower performance represented by the blue curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold. 





### Vary mu {#optim-op-point-vary-mu}

For $\nu = 1$ and $\lambda= 1$ wAFROC-AUC and Youden-index based optimizations were performed for 4 values of $\mu = 0.75,1,1.25,1.5$. Table \@ref(tab:optim-op-point-table2) summarizes the results.  



```{r optim-op-point-computations-mu, cache = FALSE, echo=FALSE}
nu <- 1
lambda <- 1
muArr <- c(0.75,1,1.25,1.5)
fomMaxArr <- array(dim = c(2,length(muArr)))
zetaOptArr <- array(dim = c(2,length(muArr)))
rocAucArr <- array(dim = c(2,length(muArr)))
nlfOptArr <- array(dim = c(2,length(muArr)))
llfOptArr <- array(dim = c(2,length(muArr)))
for (y in 1:2) {
  for (i in 1:length(muArr)) {
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    muArr[i], 
                    lambda, 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      fomMaxArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        muArr[i], 
        lambda, 
        nu, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        muArr[i], 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        muArr[i], 
        nu)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    muArr[i], 
                    lambda, 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      fomMaxArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        muArr[i], 
        lambda, 
        nu, zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        muArr[i], 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        muArr[i], 
        nu)
    } else stop("incorrect y")
  }
}
```






```{r optim-op-point-table3-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), mu = muArr, zeta1 = simplePrint(zetaOptArr[1,]), wFROC = simplePrint(fomMaxArr[1,]), ROC = simplePrint(rocAucArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), mu = muArr, zeta1 = simplePrint(zetaOptArr[2,]), wFROC = simplePrint(fomMaxArr[2,]), ROC = simplePrint(rocAucArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "mu", "zeta1", "wAFROC", "ROC", "OptOpPt")
```



```{r optim-op-point-table3, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\nu = 1$, $\\lambda = 1$ and different values of $\\mu$.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```



* From Table \@ref(tab:optim-op-point-table3) for the lowest value $\mu = 0.75$ the end-point of the FROC, corresponding to $\zeta_1 = -\infty$, is the farthest to the right and lowest in the vertical direction, and the optimal operating point is closest to the origin, i.e., `r OpPtStr(nlfOptArr[1,1], llfOptArr[1,1])`. wAFROC-AUC performance = `r simplePrint(fomMaxArr[1,1])` is least as is ROC-AUC = `r simplePrint(rocAucArr[1,1])`. ^[With even lower performance - achieved by choosing, for example, a smaller value of $\mu$, both wAFROC and ROC AUCs approach 0.5 and the optimal operating point is at the origin - basically the algorithm is so poor that none of its marks should be shown to the radiologist.] 

* As $\mu$ increases, the FROC end-point moves to the upper left and the optimal operating point moves up.

* At the highest value $\mu = 1.5$ the end-point of the FROC is the closest to (0,1), and the optimal operating point is farthest from the origin, i.e., `r OpPtStr(nlfOptArr[1,4], llfOptArr[1,4])`. wAFROC-AUC performance = `r simplePrint(fomMaxArr[1,4])` is greatest as is ROC-AUC = `r simplePrint(rocAucArr[1,4])`. With good performance one shows lower confidence level marks: $\zeta_1$ = `r simplePrint(zetaOptArr[1,4])` than is possible with poorer performance. With even higher values of $\mu$ both wAFROC and ROC AUCs approach 1 and the optimal operating point approaches (0,1) - the algorithm is so good that all of its marks should be shown to the radiologist. 

* At the lowest value $\mu = 0.75$ the end-point of the FROC is at `r OpPtStr(nlfOptArr[2,1], llfOptArr[2,1])`. wAFROC-AUC performance = `r simplePrint(fomMaxArr[2,1])` and ROC-AUC = `r simplePrint(rocAucArr[2,1])`, both of which are smaller than the values obtained using wAFROC-AUC maximization. 

* At the highest value $\mu = 1.5$ the end-point of the FROC at `r OpPtStr(nlfOptArr[2,4], llfOptArr[2,4])`. wAFROC-AUC performance = `r simplePrint(fomMaxArr[2,4])` and ROC-AUC = `r simplePrint(rocAucArr[2,4])`, both of which are smaller that the values obtained using wAFROC-AUC maximization. 

* TBA With one exception the operating points in the right panel are below-left (i.e., represent higher thresholds) those in the left panel. The Youden-index based optimization yields stricter reporting threshold. Somewhat paradoxically, for the lowest value of $\mu$ the method predicts a lenient threshold.  





```{r, echo=FALSE}
froc <- array(list(), dim = c(2))
for (y in 1:2) {
  froc[[y]] <- ggplot2::ggplot()
  for ( i in 1:length(muArr)) {
    z <- seq(-5,zetaOptArr[y,i]+5,0.1)
    xFROC <- RSM_xFROC(z, muArr[i], lambda)
    yFROC <- RSM_yFROC(z, muArr[i], nu) 
    df_froc <- data.frame(NLF = xFROC, LLF = yFROC)
    froc[[y]] <- froc[[y]] + 
      geom_line(data = df_froc, aes(x = NLF, y = LLF))
    optPt <- data.frame(
      NLF = nlfOptArr[y,i], 
      LLF = llfOptArr[y,i]) 
    froc[[y]] <- froc[[y]] + 
      geom_point(data = optPt, 
                 aes(x = NLF, y = LLF),  
                 color = i)
  }
}
```



Fig. \@ref(fig:optim-op-point-vary-mu) shows FROC curves with superimposed optimal operating points. 


```{r optim-op-point-vary-mu, fig.cap="Left panel: maximized wAFROC-AUC was used to find optimal $\\zeta_1$. Right panel: maximized Youden-index was used to find optimal $\\zeta_1$. Dot colors: black means $\\mu = 0.75$, red means $\\mu = 1$, green means $\\lambda = 1.25$ and blue means $\\mu = 1.5$.", fig.show='hold', echo=FALSE}
grid.arrange(froc[[1]], froc[[2]], ncol = 2)
```


For each of the four values of $\mu$ the left panel in Fig. \@ref(fig:optim-op-point-vary-mu) shows the optimal operating point when wAFROC-AUC is maximized. It shows the FROC curves with optimal operating points superimposed. These illustrate the previous comments, namely, as $\mu$ increases, *the optimal operating point moves up the FROC curve*.



The right panel in Fig. \@ref(fig:optim-op-point-vary-mu) shows the optimal operating point when the Youden-index is maximized. 



To visualize true performance one compares wAFROC curves.    



```{r, echo=FALSE}
wafroc <- PlotRsmOperatingCharacteristics(
     muArr[c(4,4)],
     c(lambda,lambda),
     c(nu,nu),
     c(zetaOptArr[1,4], zetaOptArr[2,4]),
     lesDistr,
     relWeights,
     OpChType = "wAFROC",
     legendPosition = "null"
)$wAFROCPlot
```


```{r optim-op-point-vary-mu-wafroc, fig.cap="wAFROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\\lambda = 1$, $\\nu = 1$ and $\\mu = 1.5$. The optimal reporting theshold $\\zeta_1$ is determined by the selected FOM. The red curve corresponds to FOM = wAFROC-AUC and the blue curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the wAFROC.", fig.show='hold', echo=FALSE}
grid.arrange(wafroc)
```


Each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table3), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,4])` for the red curve, and $\zeta_1$ = `r simplePrint(zetaOptArr[2,4])` for the blue curve. The lower performance represented by the blue curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold. 




## Using the method {#optim-op-point-how-to-use-method}
Assume that one has designed an algorithmic observer that has been optimized with respect to all other parameters except the reporting threshold. At this point the algorithm reports every suspicious region, no matter how low the malignancy index. The mark-rating pairs are entered into a `RJafroc` format Excel input file. The next step is to read the data file -- `DfReadDataFile()` -- convert it to an ROC dataset -- `DfFroc2Roc()` -- and then perform a radiological search model (RSM) fit to the dataset using function `FitRsmRoc()`. This yields the necessary $\lambda, \mu, \nu$ parameters. These values are used to perform the computations described in the embedded code in this chapter, see for example Section \@ref(optim-op-point-vary-lambda). This determines the optimal reporting threshold. The RSM parameter values and the reporting threshold determine the optimal reporting point on the FROC curve. The designer sets the algorithm to only report marks with confidence levels exceeding this threshold. 




## An application {#optim-op-point-application}

TBA Fit the LROC dataset to the RSM.

```{r}
ds <- datasetCadSimuFroc
dsCad <- DfExtractDataset(ds, rdrs = 1)
dsCadRoc <- DfFroc2Roc(dsCad)
dsCadRocBinned <- DfBinDataset(dsCadRoc, opChType = "ROC")
lesDistr <- c(1)
fit <- FitRsmRoc(dsCadRocBinned, lesDistr)
mu <- fit$mu
lambdaP <- fit$lambdaP
nuP <- fit$nuP
x <- UtilPhysical2IntrinsicRSM(mu, lambdaP, nuP)
lambda <- x$lambda
nu <- x$nu
```



```{r optim-op-point-computations-application, cache = FALSE, echo=FALSE}
fomMaxArr <- array(dim = c(2,1))
zetaOptArr <- array(dim = c(2,1))
rocAucArr <- array(dim = c(2,1))
nlfOptArr <- array(dim = c(2,1))
llfOptArr <- array(dim = c(2,1))
relWeights <- c(1)
for (y in 1:2) {
  for (i in 1:length(lambda)) {
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambda, 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      fomMaxArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambda[i], 
        nu, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda = lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nu)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambda[i], 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      fomMaxArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambda[i], 
        nu, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda = lambda[i])
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, mu, nu)
    } else stop("incorrect y")
  }
}
```


Table \@ref(tab:optim-op-point-table4) summarizes the results.

```{r optim-op-point-table4-contents, echo=FALSE}
x1 <- cbind("wAFROC", lambda = simplePrint(lambda), zeta1 = simplePrint(zetaOptArr[1,1]), wFROC = simplePrint(fomMaxArr[1,1]), ROC = simplePrint(rocAucArr[1,1]), OptOpPt = OpPtStr(nlfOptArr[1,1], llfOptArr[1,1]))
x2 <- cbind("Youden", lambda = simplePrint(lambda), zeta1 = simplePrint(zetaOptArr[2,1]), wFROC = simplePrint(fomMaxArr[2,1]), ROC = simplePrint(rocAucArr[2,1]), OptOpPt = OpPtStr(nlfOptArr[2,1], llfOptArr[2,1]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "lambda", "zeta1", "wAFROC", "ROC", "OptOpPt")
```


```{r optim-op-point-table4, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for example FROC dataset.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```




```{r, echo=FALSE}
froc <- ggplot2::ggplot()
z <- seq(-5,zetaOptArr[1,1]+5,0.1)
xFROC <- RSM_xFROC(z, mu, lambda)
yFROC <- RSM_yFROC(z, mu, nu) 
df_froc <- data.frame(NLF = xFROC, LLF = yFROC)
froc  <- froc  + 
  geom_line(data = df_froc, aes(x = NLF, y = LLF), na.rm = TRUE) +
  scale_x_continuous(limits = c(0,2)) + scale_y_continuous(limits = c(0,1))
optPt <- data.frame(
  NLF = nlfOptArr[1,1], 
  LLF = llfOptArr[1,1]) 
froc  <- froc  + 
  geom_point(data = optPt, 
             aes(x = NLF, y = LLF))
```



Fig. \@ref(fig:optim-op-point-application-froc) shows FROC curves with superimposed optimal operating points. 


```{r optim-op-point-application-froc, fig.cap="Maximized wAFROC-AUC was used to find optimal $\\zeta_1$.", fig.show='hold', echo=FALSE}
grid.arrange(froc)
```


```{r, echo=FALSE}
wafroc <- PlotRsmOperatingCharacteristics(
     mu,
     lambda,
     nu,
     zetaOptArr[1,1],
     lesDistr,
     relWeights,
     OpChType = "wAFROC",
     legendPosition = "null"
)$wAFROCPlot
```


```{r optim-op-point-application-wafroc, fig.cap="Results of wAFROC-AUC based optimizations; wAFROC curves corresponding to $\\mu = 0.75$, red curve, and $\\mu = 1.5$, blue curve.", fig.show='hold', echo=FALSE}
grid.arrange(wafroc)
```




## References {#optim-op-point-references}
