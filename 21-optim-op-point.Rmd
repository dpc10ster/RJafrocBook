# Optimal operating point on FROC {#optim-op-point}

---
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: R/learn/my_header.tex
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval.after = "fig.cap"
)

library(RJafroc)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(abind)
library(dplyr)
```



```{r, echo=FALSE}
OpPtStr <- function(x,y) {
  y <- paste0("(", sprintf("%.3f", x), ", ", sprintf("%.3f", y), ")")
  return(y)
}

simplePrint <- function(x) {
  sprintf("%.3f", x)
}
```



## How much finished {#optim-op-point-how-much-finished}
40%
Major update to 21-optim-op-point.Rmd - need to resolve plots in vary mu





## Methods {#optim-op-point-methods}

TBA Vary lambda, then nu, then mu

The following code chunk defines two functions to be minimized: `wAFROC` and `Youden`. 

* Lines 2 - 17 returns `-wAFROC`, the *negative* of AUC under the wAFROC, computed by `UtilAnalyticalAucsRSM` which returns the area under the continuous section of the curve plus the area under the dotted line extension. The negative sign is needed because the default of the `optimize()` function, used later, finds the *minimum* of the supplied function. The first argument is $\zeta_1$, the variable to be varied to find the minimum. The remaining arguments are needed by `UtilAnalyticalAucsRSM`: $\mu$, $\lambda$, $\nu$, `lesDistr` and `relWeights.` The last two specify the number of lesions per case and their weights. The example below uses `lesDistr = c(0.5,0.5)`, i.e., half the abnormal cases contain one lesion and the rest contain two lesion, and `relWeights = c(0.5,0.5)` specifies equal weights.


* Lines 20 - 37 returns `-Youden`, the *negative* of the Youden-index. The Youden-index is the sum of sensitivity and specificity minus 1. Sensitivity is computed by `RSM_yROC` and specificity is 1 - `RSM_xROC`.

```{r functions_2be_maximized, echo=TRUE, attr.source = ".numberLines"}

wAFROC <- function (
  zeta1, 
  mu, 
  lambda, 
  nu, 
  lesDistr, 
  relWeights) {
  x <- UtilAnalyticalAucsRSM(
    mu, 
    lambda, 
    nu, zeta1, 
    lesDistr, 
    relWeights)$aucwAFROC
  # return negative of aucwAFROC 
  # (as optimize finds minimum of function)
  return(-x)
  
}


Youden <- function (
  zeta1, 
  mu, 
  lambda, 
  nu, 
  lesDistr, 
  relWeights) {
  # add sensitivity and specificity 
  # and subtract 1, i.e., Youden's index
  x <- RSM_yROC(
    zeta1, 
    mu, 
    lambda, 
    nu, 
    lesDistr) + 
    (1 - RSM_xROC(zeta1, lambda)) - 1
  # return negative of Youden 
  # (as optimize finds minimum of function)
  return(-x)
  
}
```


## Vary lambda  {#optim-op-point-vary-lambda}

For $\mu = 2$ and $\nu = 1$ wAFROC and Youden-index based optimizations were performed for 4 values of $\lambda = 1, 5, 10, 15$. The following quantities were calculated [In the following code the first index `y` denotes whether wAFROC-AUC is being maximized (`y` = 1, see lines 14 - 20) - or if Youden-index is being optimized (`y` = 2, see lines 39 - 45). The second index corresponds to $\lambda$.]:

* `zetaOptArr`, a [2,4] array, the optimal thresholds $\zeta_1$. 
* `maxFomArr`, a [2,4] array, the optimal values of the figures of merit, wAFROC-AUC or Youden; 
* `rocAucArr`, a [2,4] array, the AUCs under the ROC curves corresponding to optimizations based on wAFROC or Youden-index;   
* `nlfOptArr`, a [2,4] array, the abscissa of the FROC curve corresponding to optimizations based on wAFROC or Youden-index;   
* `llfOptArr`, a [2,4] array, the ordinate of the FROC curve corresponding to optimizations based on wAFROC or Youden-index.   


```{r optim-op-point-computations-lambda, cache = FALSE, echo=TRUE, attr.source = ".numberLines"}
mu <- 2
nu <- 1
lambdaArr <- c(1,5,10,15)
maxFomArr <- array(dim = c(2,length(lambdaArr)))
zetaOptArr <- array(dim = c(2,length(lambdaArr)))
rocAucArr <- array(dim = c(2,length(lambdaArr)))
nlfOptArr <- array(dim = c(2,length(lambdaArr)))
llfOptArr <- array(dim = c(2,length(lambdaArr)))
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
for (y in 1:2) {
  for (i in 1:length(lambdaArr)) {
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaArr[i], 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaArr[i], 
        nu, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda = lambdaArr[i])
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nu)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaArr[i], 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaArr[i], 
        nu, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda = lambdaArr[i])
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, mu, nu)
    } else stop("incorrect y")
  }
}
```



Table \@ref(tab:optim-op-point-table1) summarizes the results. The column labeled "FOM" shows which quantity is being maximized, the column labeled "lambda" corresponds to the values of $\lambda$, the column labeled "wAFROC" is the AUC under the wAFROC curve, the column labeled "ROC" is the AUC under the ROC curve and the column labeled "OptOpPt" is the optimal operating point on the FROC curve.

Comments on table TBA ...

TBA Youden index based optimizations yield lower wAFROC-AUCs than wAFROC based optimizations. Attributable to excessively high values of $\zeta_1$. ROC AUC > wAFROC AUC. 



```{r optim-op-point-table1-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), lambda = lambdaArr, zeta1 = simplePrint(zetaOptArr[1,]), wFROC = simplePrint(maxFomArr[1,]), ROC = simplePrint(rocAucArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), lambda = lambdaArr, zeta1 = simplePrint(zetaOptArr[2,]), wFROC = simplePrint(maxFomArr[2,]), ROC = simplePrint(rocAucArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "lambda", "zeta1", "wAFROC", "ROC", "OptOpPt")
```



```{r optim-op-point-table1, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\mu = 2$ and $\\nu = 1$ .", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```



It remains to display the FROC curves with superimposed optimal operating points. One could generate 8 FROC plots, each corresponding to the two FOMS and the 4 $\lambda$ values, with the optimal operating point superposed, but there is a more efficient method. The FROC curve is defined by the search model parameters as follows:



\begin{equation}
\left. 
\begin{aligned}
NLF \left ( \zeta, \lambda' \right ) =& \lambda' \Phi \left (-\zeta \right ) \\
LLF\left ( \zeta, \mu, \nu', \overrightarrow{f_L} \right ) =& \nu' \Phi \left ( \mu - \zeta \right ) 
\end{aligned}
\right \}
(\#eq:rsm-froc-predictions)
\end{equation}

The physical parameters $\lambda'$ and $\nu'$ are related to the intrinsic parameters $\mu$, $\lambda$ and $\nu$ by: 

\begin{equation}
\left. 
\begin{aligned}
\lambda' =& \frac{\lambda  }{\mu} \\
\nu' =& 1 - exp\left (-\mu \nu \right ) 
\end{aligned}
\right \}
(\#eq:rsm-intrinsic-physical)
\end{equation}


In the current example, the $\lambda'$ values are $\lambda' = 0.5, 2.5, 5, 7.5$. Since the maximum value of the $\Phi$ function is unity, the *four FROC curves are scaled versions of a single curve whose x-axis ranges from 0 to 1*, corresponding to $\lambda' = 1$. The other curves are obtained by stretching this curve along the x-axis by the appropriate $\lambda'$ factor. With this understanding one can display 4 FROC curves with a single FROC curve where the x-axis is $NLF \left ( \zeta, \lambda' = 1 \right )$. The true FROC curve is defined by:  



\begin{equation}
\left. 
\begin{aligned}
NLF \left ( \zeta, \lambda' \right ) =& \lambda' NLF \left ( \zeta, \lambda' = 1 \right ) \\
LLF\left ( \zeta, \mu, \nu', \overrightarrow{f_L} \right ) =& \nu' \Phi \left ( \mu - \zeta \right ) 
\end{aligned}
\right \}
(\#eq:rsm-froc-predictions2)
\end{equation}


To get from the true FROC curve to the $\lambda' = 1$ version one divides the true abscissa by $\lambda'$. In the following code `lambdaP` denotes $\lambda'$ and the appropriate scaling of the x-axis occurs at line 7. To be consistent the x-coordinate of the optimal operating point must by likewise scaled, line 16. The following code generates, for each value of `y`, the scaled FROC curve with the scaled optimal operating points. The left panel corresponds to the wAFROC-AUC based optimization and the right to the Youden-index based optimization. 



```{r, attr.source = ".numberLines", echo=FALSE}
scaled_froc <- array(list(), dim = 2)
for (y in 1:2) {
  i <- 1 # no need to generate scaled FROC 4 times
  z <- seq(-5,zetaOptArr[y,i]+5,0.1)
  lambdaP <- lambdaArr[i] / mu
  # scale x-axis to range (0,1) by dividing by lambdaP
  xFROC <- RSM_xFROC(z, mu, lambdaArr[i]) / lambdaP
  yFROC <- RSM_yFROC(z, mu, nu)
  df_scaled_froc <- data.frame(
    NLF_scaled = xFROC, 
    LLF = yFROC)
  scaled_froc[[y]] <- ggplot2::ggplot(
    df_scaled_froc, 
    aes(x = NLF_scaled, y = LLF)) + 
    geom_line() +
    scale_x_continuous(limits = c(0,1)) + 
    scale_y_continuous(limits = c(0,1))
  for ( i in 1:length(lambdaArr)) {
    lambdaP <- lambdaArr[i] / mu
    # scale NLF value by dividing 
    # by lambdaP to match scaling of x-axis
    optPt <- data.frame(
      NLF_scaled = nlfOptArr[y,i] / lambdaP, 
      LLF = llfOptArr[y,i])
    scaled_froc[[y]] <- scaled_froc[[y]] + 
      geom_point(data = optPt, color = i)
  }
}
```




```{r optim-op-point-vary-lambda, fig.cap="Left panel: maximized wAFROC AUC was used to find optimal $\\zeta_1$. Right panel: maximized Youden index was used to find optimal $\\zeta_1$. Dot colors: black means $\\lambda = 1$, red means $\\lambda = 5$, green means $\\lambda = 10$ and blue means $\\lambda = 15$.", fig.show='hold', echo=FALSE}
grid.arrange(scaled_froc[[1]], scaled_froc[[2]], ncol = 2)
```


The left panel in \@ref(fig:optim-op-point-vary-lambda) shows the optimal operating point when wAFROC-AUC is maximized. The 4 operating points are color coded as follows:

* The black dot corresponds to $\lambda = 1$, i.e., $\lambda' = 1/2 = 0.5$. In other words, the true FROC is obtained by *shrinking* that shown, including the black dot, along the x-axis by a factor of 2.  
* The red dot corresponds to $\lambda' = 2.5$. In other words, the true FROC is obtained by *magnifying* that shown, including the black dot, along the x-axis by a factor of 2.5.   
* The green dot corresponds to $\lambda' = 5$. 
* The blue dot corresponds to $\lambda' = 7.5$.  

TBA As $\lambda'$ increases, the optimal operating point moves down the scaled curve.

TBA The right panel shows the optimal operating point when the Youden index is maximized. It shows the same general features as the previous example - the optimal operating point moves down the scaled curve - and additionally, the group of four operating points in the right panel are below-left those in the left panel, representing higher values of optimal $\zeta_1$, i.e., a more stringent criteria. 



## Vary nu {#optim-op-point-vary-nu}

For $\mu = 2$ and $\lambda= 5$ wAFROC and Youden-index based optimizations were performed for 4 values of $\nu = 0.1,0.5,1,2$. 



```{r optim-op-point-computations-nu, cache = FALSE, echo=FALSE, attr.source = ".numberLines"}
mu <- 2
lambda <- 5
nuArr <- c(0.1,0.5,1,2)
maxFomArr <- array(dim = c(2,length(nuArr)))
zetaOptArr <- array(dim = c(2,length(nuArr)))
rocAucArr <- array(dim = c(2,length(nuArr)))
nlfOptArr <- array(dim = c(2,length(nuArr)))
llfOptArr <- array(dim = c(2,length(nuArr)))
for (y in 1:2) {
  for (i in 1:length(nuArr)) {
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambda, 
                    nuArr[i], 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambda, 
        nuArr[i], 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nuArr[i])
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambda, 
                    nuArr[i], 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambda, 
        nuArr[i], 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nu = nuArr[i])
    } else stop("incorrect y")
  }
}
```



Table \@ref(tab:optim-op-point-table2) summarizes the results. 

Comments on table TBA ...

TBA Youden index based optimizations yield lower wAFROC-AUCs than wAFROC based optimizations. Attributable to excessively high values of $\zeta_1$. ROC AUC > wAFROC AUC. 



```{r optim-op-point-table2-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), nu = nuArr, zeta1 = simplePrint(zetaOptArr[1,]), wFROC = simplePrint(maxFomArr[1,]), ROC = simplePrint(rocAucArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), nu = nuArr, zeta1 = simplePrint(zetaOptArr[2,]), wFROC = simplePrint(maxFomArr[2,]), ROC = simplePrint(rocAucArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "nu", "zeta1", "wAFROC", "ROC", "OptOpPt")
```



```{r optim-op-point-table2, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\mu = 2$ and $\\lambda = 5$ .", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```



Fig. \@ref(fig:optim-op-point-vary-nu) shows the FROC curves with optimal operating points superimposed. The left panel corresponds to wAFROC-AUC based optimizations while the right panel corresponds to Youden-index based optimizations.



```{r, attr.source = ".numberLines", echo=FALSE}
froc <- array(list(), dim = c(2))
for (y in 1:2) {
  froc[[y]] <- ggplot2::ggplot()
  for ( i in 1:length(nuArr)) {
    z <- seq(-5,zetaOptArr[y,i]+5,0.1)
    xFROC <- RSM_xFROC(z, mu, lambda)
    yFROC <- RSM_yFROC(z, mu, nuArr[i]) 
    df_froc <- data.frame(NLF = xFROC, LLF = yFROC)
    froc[[y]] <- froc[[y]] + 
      geom_line(data = df_froc, aes(x = NLF, y = LLF))
    optPt <- data.frame(
      NLF = nlfOptArr[y,i], 
      LLF = llfOptArr[y,i]) 
    froc[[y]] <- froc[[y]] + 
      geom_point(data = optPt, 
                 aes(x = NLF, y = LLF),  
                 color = i)
  }
}
```




```{r optim-op-point-vary-nu, fig.cap="Left panel: maximized wAFROC AUC was used to find optimal $\\zeta_1$. Right panel: maximized Youden index was used to find optimal $\\zeta_1$. Dot colors: black means $\\nu = 0.1$, red means $\\nu = 0.5$, green means $\\nu = 1$ and blue means $\\nu = 2$.", fig.show='hold', echo=FALSE}
grid.arrange(froc[[1]], froc[[2]], ncol = 2)
```


TBA The left panel in \@ref(fig:optim-op-point-vary-nu) shows the optimal operating point when wAFROC-AUC is maximized. The 4 operating points are color coded as follows:

* TBA The black dot corresponds to $\nu = 0.1$.  
* The red dot corresponds to $\nu = 0.5$.  
* The green dot corresponds to $\nu = 1$.  
* The blue dot corresponds to $\nu = 2$. 

TBA As $\lambda'$ increases, the optimal operating point moves down the scaled curve.

TBA The right panel shows the optimal operating point when the Youden index is maximized. It shows the same general features as the previous example - the optimal operating point moves down the scaled curve - and additionally, the group of four operating points in the right panel are below-left those in the left panel, representing higher values of optimal $\zeta_1$, i.e., a more stringent criteria. 






## Vary mu {#optim-op-point-vary-mu}

For $\nu = 1$ and $\lambda= 1$ wAFROC and Youden-index based optimizations were performed for 4 values of $\mu = 0.75,1,1.25,1.5$. 



```{r optim-op-point-computations-mu, cache = FALSE, echo=FALSE, attr.source = ".numberLines"}
nu <- 1
lambda <- 1
muArr <- c(0.75,1,1.25,1.5)
maxFomArr <- array(dim = c(2,length(muArr)))
zetaOptArr <- array(dim = c(2,length(muArr)))
rocAucArr <- array(dim = c(2,length(muArr)))
nlfOptArr <- array(dim = c(2,length(muArr)))
llfOptArr <- array(dim = c(2,length(muArr)))
for (y in 1:2) {
  for (i in 1:length(muArr)) {
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    muArr[i], 
                    lambda, 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        muArr[i], 
        lambda, 
        nu, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        muArr[i], 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        muArr[i], 
        nu)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    muArr[i], 
                    lambda, 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        muArr[i], 
        lambda, 
        nu, zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        muArr[i], 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        muArr[i], 
        nu)
    } else stop("incorrect y")
  }
}
```



Table \@ref(tab:optim-op-point-table2) summarizes the results. 

Comments on table TBA ...

TBA Youden index based optimizations yield lower wAFROC-AUCs than wAFROC based optimizations. Attributable to excessively high values of $\zeta_1$. ROC AUC > wAFROC AUC. 



```{r optim-op-point-table3-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), mu = muArr, zeta1 = simplePrint(zetaOptArr[1,]), wFROC = simplePrint(maxFomArr[1,]), ROC = simplePrint(rocAucArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), mu = muArr, zeta1 = simplePrint(zetaOptArr[2,]), wFROC = simplePrint(maxFomArr[2,]), ROC = simplePrint(rocAucArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "mu", "zeta1", "wAFROC", "ROC", "OptOpPt")
```



```{r optim-op-point-table3, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\nu = 1$ and $\\lambda = 1$ .", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```



Fig. \@ref(fig:optim-op-point-vary-mu) shows FROC curves with superimposed optimal operating points. 




```{r, attr.source = ".numberLines", echo=FALSE}
froc <- array(list(), dim = c(2))
for (y in 1:2) {
  froc[[y]] <- ggplot2::ggplot()
  for ( i in 1:length(muArr)) {
    z <- seq(-5,zetaOptArr[y,i]+5,0.1)
    xFROC <- RSM_xFROC(z, muArr[i], lambda)
    yFROC <- RSM_yFROC(z, muArr[i], nu) 
    df_froc <- data.frame(NLF = xFROC, LLF = yFROC)
    froc[[y]] <- froc[[y]] + 
      geom_line(data = df_froc, aes(x = NLF, y = LLF))
    optPt <- data.frame(
      NLF = nlfOptArr[y,i], 
      LLF = llfOptArr[y,i]) 
    froc[[y]] <- froc[[y]] + 
      geom_point(data = optPt, 
                 aes(x = NLF, y = LLF),  
                 color = i)
  }
}
```




```{r optim-op-point-vary-mu, fig.cap="Left panel: maximized wAFROC AUC was used to find optimal $\\zeta_1$. Right panel: maximized Youden-index was used to find optimal $\\zeta_1$. Dot colors: black means $\\mu = 0.75$, red means $\\mu = 1$, green means $\\lambda = 1.25$ and blue means $\\mu = 1.5$.", fig.show='hold', echo=FALSE}
grid.arrange(froc[[1]], froc[[2]], ncol = 2)
```


For each of the four values of $\mu$ the left panel in Fig. \@ref(fig:optim-op-point-vary-mu) shows the optimal operating point when wAFROC-AUC is maximized. 

* From Table \@ref(tab:optim-op-point-table3) for the lowest value $\mu = 0.75$ the end-point of the FROC, corresponding to $\zeta_1 = -\infty$, is the farthest to the right and lowest in the vertical direction, and the optimal operating point is closest to the origin, i.e., `r OpPtStr(nlfOptArr[1,1], llfOptArr[1,1])`. wAFROC-AUC performance = `r simplePrint(maxFomArr[1,1])` is least as is ROC-AUC = `r simplePrint(rocAucArr[1,1])` is close to chance level. With very poor performance it is prudent to only show very high confidence level marks: $\zeta_1$ = `r simplePrint(zetaOptArr[1,1])`. With even lower performance - achieved by choosing, for example, a smaller value of $\mu$, both wAFROC and ROC AUCs approach 0.5 and the optimal operating point is at the origin - basically the algorithm is so poor that none of its marks deserve to be shown to the radiologist. 

* As $\mu$ increases, the optimal operating point moves upwards along the relevant curve.

* At the highest value $\mu = 1.5$ the end-point of the FROC is the closest to the right and highest in the vertical direction, and the optimal operating point is farthest from the origin, i.e., `r OpPtStr(nlfOptArr[1,4], llfOptArr[1,4])`. wAFROC-AUC performance = `r simplePrint(maxFomArr[1,4])` is least as is ROC-AUC = `r simplePrint(rocAucArr[1,4])` is quite good. With good performance it makes sense to show lower confidence level marks: $\zeta_1$ = `r simplePrint(zetaOptArr[1,4])`. With even higher values of $\mu$ both wAFROC and ROC AUCs approach 1 and the optimal operating point approaches (0,1) - the algorithm is so good that all of its marks deserve to be shown to the radiologist. 

The right panel in Fig. \@ref(fig:optim-op-point-vary-mu) shows the optimal operating point when the Youden-index is maximized. 

* At the lowest value $\mu = 0.75$ the end-point of the FROC at `r OpPtStr(nlfOptArr[2,1], llfOptArr[2,1])`. wAFROC-AUC performance = `r simplePrint(maxFomArr[2,1])` and ROC-AUC = `r simplePrint(rocAucArr[2,1])`, both of which are smaller than the values obtained using wAFROC-AUC maximization. 

* At the highest value $\mu = 1.5$ the end-point of the FROC at `r OpPtStr(nlfOptArr[2,4], llfOptArr[2,4])`. wAFROC-AUC performance = `r simplePrint(maxFomArr[2,4])` and ROC-AUC = `r simplePrint(rocAucArr[2,4])`, both of which are smaller that the values obtained using wAFROC-AUC maximization. 

* With one exception the operating points in the right panel are below-left (i.e., represent higher thresholds) those in the left panel. The Youden-index based optimization yields stricter reporting threshold. Somewhat paradoxically, for the lowest value of $\mu$ the method predicts a lenient threshold.  






## References {#optim-op-point-references}
