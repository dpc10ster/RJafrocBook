# Optimal operating point on FROC {#optim-op-point-froc}

---
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: R/learn/my_header.tex
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval.after = "fig.cap"
)

library(RJafroc)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(abind)
library(dplyr)
```


## How much finished {#optim-op-point-froc-how-much-finished}
10%


## Introduction {#optim-op-point-froc-intro}
A CAD system yields FROC mark-rating data where the (continuous scale) ratings are available to the algorithm designer and only mark-rating data with ratings exceeding a pre-selected threshold are to be displayed to the radiologist. The problem addressed in this chapter is how to select the optimal threshold.

* It is taken as an axiomatic truth that *the optimal reporting threshold $\zeta_{\text{max}}$ is that value of $\zeta_1$ that maximizes the AUC under the wAFROC*.  

* This chapter examines the effect of changing the reporting threshold $\zeta_1$ on the wAFROC AUC, with the object of determining the value that maximizes the AUC.

## Dependence of ROC performance on threshold {#optim-op-point-froc-dependence-threshold-roc}
It is clear that moving the reporting threshold $\zeta_1$ along the ROC curve does not change the *total* area under the ROC curve. This was the reason, Chapter TBA, for preferring, as a figure of merit, the AUC under the full curve in lieu of reported sensitivity-specificity pairs. One might incorrectly assume that this means that performance is independent of reporting threshold. When $\zeta_1 = -\infty$ then performance, represented by the area $\text{AUC}$ under the full continuous curve shown below (left plot), is indeed independent of reporting threshold (trivially, because the latter is constant at $-\infty$). However, if the observer adopts a finite reporting threshold $\zeta_1$ then the ROC curve stops at an operating point (solid dot, left plot) that is below-left of (1,1). *Net performance, represented by the area under the continuous section up to the solid dot plus the area under the dashed line in the left plot*, is denoted $\text{AUC}(\zeta_1)$, which depends on $\zeta_1$. It is clear from the left plot that $\text{AUC}(\zeta_1) \le \text{AUC}$. The left plot also demonstrates that $\text{AUC}(\zeta_1)$ as a function of $\zeta_1$ has a maximum at $\zeta_1 = -\infty$. In other words, using the ROC figure of merit, performance of the CAD algorithm is maximized by displaying *all* the marks. 

The restriction above to the left plot is because it is (almost) a proper ROC curve ^[whenever $b \ne 1$ the binormal ROC curve is improper, although the "hook" may not be readily visible under normal plotting conditions.]. For a proper ROC curve the slope decreases continuously as one moves up the plot. This ensures that the continuous section to the right of the solid dot in the left plot is always *above* the dashed line. The right plot (a = 1, b = 0.2) illustrates the situation when the curve is visibly improper. Now the dashed line is mostly above the continuous section and performance is maximized at a finite value of $\zeta_1$: an invalid conclusion because the improper ROC curve is a fitting artifact of the binormal model.  

```{r echo=FALSE}
a <- 2; b <- 0.8; zeta1Arr <- seq(1.5,5.5,0.05)
zeta1ArrAll <- seq(-3,5.5,0.05)
FPF <- pnorm(-zeta1Arr)
TPF <- pnorm(a - b*zeta1Arr)
#truncated <- data.frame(FPF = FPF, TPF = TPF)
continuous <- data.frame(FPF = pnorm(-zeta1ArrAll), TPF = pnorm(a - b*zeta1ArrAll))
dashed <- data.frame(FPF = c(FPF[1], 1), TPF = c(TPF[1], 1))
endPoint <- data.frame(x = FPF[1], y = TPF[1])
p1 <- ggplot2::ggplot(continuous, aes(x = FPF, y = TPF)) + 
  geom_line() + 
  geom_line(data = dashed, aes(x = FPF, y = TPF), linetype = 3) + 
  geom_point(data = endPoint, aes(x = x, y = y), size = 4) + 
  scale_x_continuous(limits = c(0,1)) + scale_y_continuous(limits = c(0,1))
```



```{r echo=FALSE}
a <- 1; b <- 0.2; zeta1Arr <- seq(1.5,5.5,0.05)
zeta1ArrAll <- seq(-10,15,0.05)
FPF <- pnorm(-zeta1Arr)
TPF <- pnorm(a - b*zeta1Arr)
#truncated <- data.frame(FPF = FPF, TPF = TPF)
continuous <- data.frame(FPF = pnorm(-zeta1ArrAll), TPF = pnorm(a - b*zeta1ArrAll))
dashed <- data.frame(FPF = c(FPF[1], 1), TPF = c(TPF[1], 1))
endPoint <- data.frame(x = FPF[1], y = TPF[1])
p2 <- ggplot2::ggplot(continuous, aes(x = FPF, y = TPF)) + 
  geom_line() + 
  geom_line(data = dashed, aes(x = FPF, y = TPF), linetype = 3) + 
  geom_point(data = endPoint, aes(x = x, y = y), size = 4) + 
  scale_x_continuous(limits = c(0,1)) + scale_y_continuous(limits = c(0,1))
```



```{r optim-op-point-froc-dependence-threshold-roc-plot1, fig.cap="Left plot: almost proper binormal ROC curve corresponding to a = 2 and b = 0.8. The solid dot is the operating point corresponding to $\\zeta_1 = 1.5$. The solid curve corresponds to $\\zeta_1 = -\\infty$. Note that the solid curve is above the dashed line. Right plot: improper binormal ROC curve corresponding to a = 1 and b = 0.2. The solid curve is below the dashed line.", fig.show='hold', echo=FALSE}
grid.arrange(p1, p2, ncol = 2)
```


## Dependence of FROC performance on threshold {#optim-op-point-froc-dependence-threshold-froc}
The situation is different if one uses the wAFROC figure of merit. Consider the three wAFROC plots shown below. These correspond to $\mu = 2$, $\lambda = 5$, $\nu = 1$, one lesion per case, and values of $\zeta_1$, from left to right: $\zeta_1 = 2$, $\zeta_1 = 1$ and $\zeta_1 = -1$. The area under the wAFROC curve in the middle plot is actually greater than that for the plots on either side of it, a fact that be difficult to appreciate, but is brought out more clearly in the next plot.  

```{r, echo=FALSE}
mu <- 2
lambda <- 5
nu <- 1
L <- 1
zeta1 <- 2
lesDistr <- c(rep(0, L-1), 1)
ret1 <- PlotRsmOperatingCharacteristics(
  mu, lambda, nu, zeta1, 
  lesDistr = L, legendPosition  = "none",
  llfRange = c(0,1)
)
p1 <- ret1$wAFROCPlot
```


```{r, echo=FALSE}
zeta1 <- 1
ret1 <- PlotRsmOperatingCharacteristics(
  mu, lambda, nu, zeta1, 
  lesDistr = L, legendPosition  = "none",
  llfRange = c(0,1)
)
p2 <- ret1$wAFROCPlot
```



```{r, echo=FALSE}
zeta1 <- -1
ret1 <- PlotRsmOperatingCharacteristics(
  mu, lambda, nu, zeta1, 
  lesDistr = L, legendPosition  = "none",
  llfRange = c(0,1)
)
p3 <- ret1$wAFROCPlot
```



```{r optim-op-point-froc-dependence-threshold-roc-plot2, fig.cap="Left plot: almost proper binormal ROC curve corresponding to a = 2 and b = 0.8. The solid dot is the operating point corresponding to $\\zeta_1 = 1.5$. The solid curve corresponds to $\\zeta_1 = -\\infty$. Note that the solid curve is above the dashed line. Right plot: improper binormal ROC curve corresponding to a = 1 and b = 0.2. The solid curve is below the dashed line.", fig.show='hold', echo=FALSE}
grid.arrange(p1, p2, p3, ncol = 3)
```


The next plot, in which three previous plots are effectively superposed, shows the differences in areas more clearly. The green plot (solid green line plus the dashed green line) clearly has the least area; it corresponds to $\zeta_1 = 2$. The "green-red" plot (i.e., the solid green line plus the solid red line plus the dashed red line) has the greatest area; it corresponds to $\zeta_1 = 1$. The "green-red-blue" plot (i.e., the solid green line plus the solid red line plus the solid blue line plus the dashed blue line) has area slightly smaller than that of the "green-red" plot; it corresponds to $\zeta_1 = -1$. Decreasing $\zeta_1$ from 2 to -1 reveals a maximum in area under the wAFROC curve. A more precise determination of the optimal value of $\zeta_1$, using numerical search, will be shown next, but it is clear a maximum exists and that it does not correspond to $\zeta_1 = -\infty$, in other words it does not correspond to showing all the marks, as was the case if one uses the ROC figure of merit. 

The essential difference between the ROC and the wAFROC example is this: moving up the curve, a proper ROC curve has monotonically decreasing slope and ends at (1,1) while the wAFROC curve has monotonically decreasing slope and ends at a point below-left to (1,1). This geometrical difference enables a finite optimal $\zeta_1$ for the wAFROC but not for the ROC.

In the following sections the optimal operating point determined using the wAFROC curve will be explored for two algorithmic observer, one with low performance (as compared to an expert radiologist) and one with similar performance to an expert radiologist. Since CAD developers are more familiar with FROC curves than wAFROC curves, the optimal operating points for the two algorithms will be illustrated using FROC curves. 



```{r, echo=FALSE}
df1 <- data.frame(FPF = p1$data$FPF, wLLF = p1$data$wLLF)

endPoint1 <- data.frame(FPF = p1$data$FPF[1], wLLF = p1$data$wLLF[1])
section2 <- which(p2$data$FPF >= endPoint1$FPF)
df2 <- data.frame(FPF = p2$data$FPF[section2], 
                  wLLF = p2$data$wLLF[section2])

endPoint2 <- data.frame(FPF = p2$data$FPF[1], wLLF = p2$data$wLLF[1])
section3 <- which(p3$data$FPF >= endPoint2$FPF)
df3 <- data.frame(FPF = p3$data$FPF[section3], 
                  wLLF = p3$data$wLLF[section3])

endPoint3 <- data.frame(FPF = p3$data$FPF[1], wLLF = p3$data$wLLF[1])
dashed1 <- data.frame(FPF = c(p1$data$FPF[1], 1), wLLF = c(p1$data$wLLF[1], 1))
dashed2 <- data.frame(FPF = c(p2$data$FPF[1], 1), wLLF = c(p2$data$wLLF[1], 1))
dashed3 <- data.frame(FPF = c(p3$data$FPF[1], 1), wLLF = c(p3$data$wLLF[1], 1))
p <- ggplot2::ggplot(data = df1, aes(x = FPF, y = wLLF)) + 
  geom_line(color = "green3") + 
  geom_point(data = endPoint1, size = 3, color = "green3") + 
  geom_line(data = dashed1, aes(x = FPF, y = wLLF), linetype = 3, color = "green3") + 
  geom_line(data = df2, color = "red") + 
  geom_point(data = endPoint2, size = 3, color = "red") + 
  geom_line(data = dashed2, aes(x = FPF, y = wLLF), linetype = 3, color = "red") + 
  geom_line(data = df3, color = "blue") + 
  geom_point(data = endPoint3, size = 3, color = "blue") + 
  geom_line(data = dashed3, aes(x = FPF, y = wLLF), linetype = 3, color = "blue") + 
  scale_x_continuous(limits = c(0,1)) + scale_y_continuous(limits = c(0,1))
print(p)
```



```{r do_one_mu, echo=FALSE}
do_one_mu <- function(mu, lambda, nu, zeta1Arr, lesDistr, relWeights) {

  fomArray <- array(dim = length(zeta1Arr))
  for (i1 in 1:length(zeta1Arr)) {
    fomArray[i1] <- UtilAnalyticalAucsRSM(mu, lambda, nu, zeta1 = zeta1Arr[i1], lesDistr, relWeights)$aucwAFROC
  }
  # generate plot of AUC vs. zeta1
  myData <- data.frame(zeta1 = zeta1Arr, AUC = fomArray)
  p <- ggplot2::ggplot(myData, aes(x = zeta1, y = AUC)) + geom_line()
  zetaMax <- zeta1Arr[which.max(fomArray)]
  return(list(
    p = p,
    zetaMax = zetaMax,
    maxFom = fomArray[which.max(fomArray)]
  ))
}
```

## Methods {#optim-op-point-froc-methods}

The aim is determine the optimal operating point on an FROC. Two values of the $\lambda$ parameter are considered: $\lambda = 10$ and $\lambda = 1$. The first value would characterize a CAD system that generates about 10 times the number of latent NL marks as an expert radiologist, while the second value would characterize a CAD system that generates about the same number of latent NL marks as an expert radiologist. The $\nu$ parameter is kept at the same, namely $\nu = 1$. Four values of the $\mu$ parameter are considered: `r c(1, 1.5, 2, 2.5)`. All else being equal, performance is expected to improve with increasing $\mu$. 

For each $\mu$ one scans a range of values of $\zeta_1$. For each $\zeta_1$ one calculates the area under the wAFROC curve - using function `UtilAnalyticalAucsRSM()`. This returns the wAFROC AUC for chosen values of parameters ($\mu$, $\lambda$, $\nu$, $\zeta_1$, and two other parameters specifying the distribution of numbers of lesions per diseased case and their weights). Repeating the procedure for different values of $\zeta_1$ one determines the value $\zeta_{\text{max}}$ that maximizes AUC -- denoted $\zeta_{\text{max}}$. Finally, using $\zeta_{\text{max}}$ one calculates the corresponding (NLF,LLF) values on the FROC and the optimal wAFROC AUC. 


### $\zeta_1$ optimization for $\lambda = 10$

Shown next is the variation of wAFROC AUC vs. $\zeta_1$ for $\lambda = 10$ and the four values of the $\mu$ parameter.

```{r maxFomArr_10, cache = FALSE, echo=TRUE}
# determine plotArr[[1,]], zetaMaxArr[1,] and maxFomArr[1,]
lambda <- 10
nu <- 1
mu_arr <- c(1, 1.5, 2, 2.5)
maxFomArr <- array(dim = c(2,length(mu_arr)))
zetaMaxArr <- array(dim = c(2, length(mu_arr)))
plotArr <- array(list(), dim = c(2, length(mu_arr)))
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
for (i in 1:length(mu_arr)) {
  if (i == 1) zeta1Arr <- seq(1.5,3.5,0.05) else zeta1Arr <- seq(0.5,2.5,0.1)
  x <- do_one_mu (mu_arr[i], lambda, nu, zeta1Arr, lesDistr, relWeights)
  plotArr[[1,i]] <- x$p + ggtitle(paste0("mu = ", as.character(mu_arr[i]), ", zetaMax = ",  format(x$zetaMax, digits = 3)))
  zetaMaxArr[1,i] <- x$zetaMax
  maxFomArr[1,i] <- x$maxFom
  # plotArr[[2,i]] etc. reserved for lambda = 1 results, done later
}
```


One sets $\lambda = 10$, $\nu = 1$ and $\mu$ to successive values 1, 1.5, 2 and 2.5. Diseased cases with one or two lesions, with equal probability (`lesDistr`), and equally weighted lesions are assumed (`relWeights`). The `plotArr` list contains the generated plots (`x$p` plus a title sting) of wAFROC AUC vs. $\zeta_1$, `zetaMaxArr` contains the value of $\zeta_1$ that maximizes wAFROC AUC (`x$zetaMax`) and `maxFomArr` contains the maximum achieved value of wAFROC AUC for each value of $\mu$ (`x$maxFom`). The first dimension of the arrays is reserved for the two values of $\lambda$. In the above code this index is set to 1, corresponding to $\lambda = 10$.


```{r optim-op-point-froc-AUC-vs-zeta1-10, fig.cap="Variation of AUC vs. $\\zeta_1$ for $\\lambda = 10$; AUC is the wAFROC AUC. panels are labeled by the value of $\\mu$ and zetaMax (i.e., $\\zeta_{\\text{max}}$, the value of $\\zeta_1$ that maximizes AUC).", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1,1]],plotArr[[1,2]],plotArr[[1,3]],plotArr[[1,4]], nrow = 2, ncol = 2)
```


Fig. \@ref(fig:optim-op-point-froc-AUC-vs-zeta1-10) corresponding to $\lambda = 10$ has four panels showing the variation of wAFROC AUC with $\zeta_1$. Each panel is labeled by the values of $\mu$ and  $\zeta_{\text{max}}$. For example, the panel labeled `mu = 1.5, zetaMax = 1.9` shows that AUC has a maximum at $\zeta_1 = 1.9$. For $\mu = 1$ the maximum is at the top of a broad plateau, but for higher values the maximum is better defined.


### $\zeta_1$ optimization for $\lambda = 1$

Shown next is the variation of wAFROC AUC vs. $\zeta_1$ for $\lambda = 1$ and the four values of the $\mu$ parameter.

```{r maxFomArr_01, cache = FALSE, echo=FALSE}
# determine plotArr[[2,]], zetaMaxArr[2,] and maxFomArr[2,]
lambda <- 1

for (i in 1:length(mu_arr)) {
  zeta1Arr <- seq(-1,1,0.05)
  fomArray <- array(dim = length(zeta1Arr))
  x <- do_one_mu (mu_arr[i], lambda, nu, zeta1Arr, lesDistr, relWeights)
  plotArr[[2,i]] <- x$p + ggtitle(paste0("mu = ", as.character(mu_arr[i]), ", zetaMax = ",  format(x$zetaMax, digits = 3)))
  zetaMaxArr[2,i] <- x$zetaMax
  maxFomArr[2,i] <- x$maxFom
}
```



```{r optim-op-point-froc-AUC-vs-zeta1-01, fig.cap="Variation of AUC vs. $\\zeta_1$ for $\\lambda = 1$.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[2,1]],plotArr[[2,2]],plotArr[[2,3]],plotArr[[2,4]], nrow = 2, ncol = 2)
```

Fig. \@ref(fig:optim-op-point-froc-AUC-vs-zeta1-01) corresponds to $\lambda = 1$ and employs a similar labeling scheme as Fig. \@ref(fig:optim-op-point-froc-AUC-vs-zeta1-10). For example, the panel labeled `mu = 1, zetaMax = 0.3` shows that AUC has a maximum at $\zeta_1 = 0.3$. 



```{r do_one_froc, echo=FALSE}
do_one_froc <- function(mu, lambda, nu, zeta1, lesDistr, relWeights, llfRange) {
  
  
  froc <- PlotRsmOperatingCharacteristics(
    mu, 
    lambda, 
    nu, 
    zeta1, 
    lesDistr = lesDistr, 
    relWeights = relWeights, 
    OpChType = "FROC",
    llfRange = llfRange,
    legendPosition = "none")$FROCPlot
  
  return(froc)
}
```



```{r detOptOpPt, cache = FALSE, echo=FALSE}
# determine optOpPt here

lambdaArr <- c(10,1)
nu <- 1
#mu_arr <- c(1, 1.5, 2, 2.5) #already defined above
#zetaMaxArr                  #already defined above
#plotArr <- array(list(), dim = c(2,length(mu_arr)))

# indices: lambda, nlf/llf, 4-values of mu
OpPtMax <- optOpPt <- array(dim = c(2, 2, 4))

for (j in 1:2) {
  for (i in 1:length(mu_arr)) {
    if ((j ==1) && (i ==1)) llfRange <- c(0, 0.1) else llfRange <- c(0,1) 
    x <- do_one_froc (mu_arr[i],
                      lambdaArr[j],
                      nu,
                      zeta1 = zetaMaxArr[j,i],
                      lesDistr, 
                      relWeights, 
                      llfRange)
    # optimal operating point
    optOpPt[j,1,i] <- max(x$data$NLF)
    optOpPt[j,2,i] <- max(x$data$LLF)
    
    # following are end-points assuming zeta1 = -Inf
    physicalValues <- UtilIntrinsic2PhysicalRSM(mu_arr[i], lambdaArr[j], nu)
    # OpPtMax[j,1,i] <- physicalValues$lambdaP*pnorm(-zetaMaxArr[j,i])
    # OpPtMax[j,2,i] <- physicalValues$nuP*pnorm(mu_arr[i]-zetaMaxArr[j,i])
    OpPtMax[j,1,i] <- physicalValues$lambdaP
    OpPtMax[j,2,i] <- physicalValues$nuP
  }
}
```



```{r useOptOpPt, cache = FALSE, echo=FALSE}

# use optOpPt here
# generate plotArr

lambdaArr <- c(10,1)
nu <- 1
# following are coordinates of extended plots
OpPtExtended <- array(dim = c(2, 2, 4))
# optOpPt defined above
#mu_arr <- c(1, 1.5, 2, 2.5) #already defined above
#zetaMaxArr                  #already defined above
plotArr <- array(list(), dim = c(2,length(mu_arr)))

correction <- array(0.5, dim = c(2, 4))

for (j in 1:2) {
  for (i in 1:length(mu_arr)) {
    if ((j ==1) && (i ==1)) llfRange <- c(0, 0.1) else llfRange <- c(0,1) 
    x <- do_one_froc (
      mu_arr[i],
      lambdaArr[j],
      nu,
      # to show a fuller extent of the plot
      zeta1 = zetaMaxArr[j,i] - correction[j,i],
      lesDistr,
      relWeights, 
      llfRange)

    plotArr[[j,i]] <- x +
      geom_vline(
        xintercept =
          optOpPt[j,1,i], color = "blue")  +
      ggtitle(
        paste0(
          as.character(lambdaArr[j]),
          "-",
          as.character(mu_arr[i])))

    OpPtExtended[j,1,i] <- max(x$data$NLF)
    OpPtExtended[j,2,i] <- max(x$data$LLF)
  }
}
```



```{r optim-op-point-froc-cad-optim-zeta1, echo=FALSE}
x1 <- as.data.frame(rbind(t(maxFomArr[1,]), t(optOpPt[1,1,]), t(optOpPt[1,2,])))
x2 <- as.data.frame(rbind(t(maxFomArr[2,]), t(optOpPt[2,1,]), t(optOpPt[2,2,])))
x12 <- rbind(x1, x2)
x12 <- cbind(c("AUC10", "NLF10", "LLF10", "AUC01", "NLF01", "LLF01"), x12)
colnames(x12) <- c("measure", paste0("mu", as.character(mu_arr)))
y <- c("AUC10", "AUC01", "NLF10", "LLF10", "NLF01", "LLF01")
x12 %>% slice(match(y, measure)) -> xFinal
```


### Summary of simulations and comments {#optim-op-point-froc-comments-threshold-optimization}


```{r optim-op-point-froc-cad-optim-table, echo=FALSE}
knitr::kable(xFinal, digits = 5, caption = "Summary of optimal threshold values: \"measure\" refers to a performance measure, \"mu1\" refers to $\\mu = 1$, etc. The row labels are as follows: AUC10 is the wAFROC AUC for lambda = 10, AUC01 is the wAFROC AUC for $\\lambda = 1$, NLF10 is NLF for $\\lambda = 10$, ..., LLF01 is LLF for $\\lambda = 1$.", escape = FALSE)
```

Table \@ref(tab:optim-op-point-froc-cad-optim-table) summarizes the results of the simulations. In this table the first two rows compare the AUCs for $\lambda=10$ and $\lambda=1$ for the four values of $\mu$. The next two rows show the operating point (NLF, LLF) for $\lambda = 10$ for the four values of $\mu$ and the final two rows are the operating point for $\lambda = 1$ for the four values of $\mu$. The following trends are evident.

* All else being equal, AUC increases with increasing $\mu$. Increasing the separation of the two unit variance normal distributions that determine the ratings of NLs and LLs leads to higher performance.
* All else being equal, AUC increases with *decreasing* $\lambda$. Decreasing the tendency of the observer to generate NLs leads to increasing performance.
* For each value of $\lambda$ optimal LLF increases with increasing $\mu$.
* For $\lambda = 10$ optimal NLF increases with increasing $\mu$.
* For $\lambda = 1$ optimal NLF *peaks* around $\mu = 1.5$.

All of these observations make intuitive sense except, perhaps, that for NLF01. To understand the peaking behavior it is necessary to examine the FROC curves corresponding to the eight -- two $\lambda$ values times four $\mu$ values -- combinations of parameters. In the following eight plots, each labeled by the appropriate $\lambda-\mu$ combination, the optimal value of NLF, corresponding to $\zeta_1 = \zeta_{\text{max}}$, is shown as a blue vertical line.

#### Explanations {#optim-op-point-froc-threshold-explanations}

```{r optim-op-point-froc-froc-10-first-two-plots, fig.cap="Extended FROC plots: panel labeled 10-1 is for $\\lambda = 10$ and $\\mu = 1$, and that labeled 10-1.5 is for $\\lambda = 10$ and $\\mu = 1.5$. The blue line indicates the optimal operating point.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[1,1]], plotArr[[1,2]], nrow = 1, ncol = 2)
```             


* In Fig. \@ref(fig:optim-op-point-froc-froc-10-first-two-plots) panel labeled **10-1** is the *extended* FROC curve for $\lambda = 10$ and $\mu = 1$. The vertical blue line is drawn at the optimal NLF corresponding to $\zeta_{\text{max}}$ for this parameter combination.  

* Note the "magnified view" scale factors chosen for Fig. \@ref(fig:optim-op-point-froc-froc-10-first-two-plots) panel labeled **10-1**. The x-axis runs from 0 to 0.03 while the y-axis runs from 0 to 0.1. Otherwise this curve would be almost indistinguishable from the x-axis. 

* In order to show a fuller extent of the FROC curve it is necessary to *extend* the curves beyond the *optimal* end-points. This was done by setting $\zeta_1$ = $\zeta_{\text{max}} - 0.5$, which has the effect of letting the curve run a little bit further to the right. As an example the *optimal* end-point for the curve in Fig. \@ref(fig:optim-op-point-froc-froc-10-first-two-plots) labeled **10-1** is (NLF = `r format(optOpPt[1,1,1], digits = 3)`, LLF = `r format(optOpPt[1,2,1], digits = 3)`) while the *extended* end-point is (NLF = `r OpPtExtended[1,1,1]`, LLF = `r OpPtExtended[1,2,1]`). The *highest* operating point, that reached when all marks are reported, is at (NLF = `r format(OpPtMax[1,1,1], digits = 3)`, LLF = `r format(OpPtMax[1,2,1], digits = 3)`). This point lies about a factor 300 to the right of the displayed curve and about a factor of six higher along the y-axis. It vividly illustrates a low-performing FROC curve.

* In Fig. \@ref(fig:optim-op-point-froc-froc-10-first-two-plots) panel labeled **10-1.5**: the vertical blue line is at NLF = `r format(optOpPt[1,1,2], digits = 3)` and the corresponding LLF is `r format(optOpPt[1,2,2], digits = 3)`. The end-point of the extended curve is (NLF = `r format(OpPtExtended[1,1,2], digits = 3)`, LLF = `r format(OpPtExtended[1,2,2], digits = 3)`). The highest operating point, that reached when all marks are reported, is at (NLF = `r format(OpPtMax[1,1,2], digits = 3)`, LLF = `r format(OpPtMax[1,2,2], digits = 3)`). 


```{r optim-op-point-froc-froc-10-next-two-plots, fig.cap="Extended FROC plots: panel labeled 10-2 is for $\\lambda = 10$ and $\\mu = 2$ and that labeled 10-2.5 is for $\\lambda = 10$ and $\\mu = 2.5$. The blue line indicates the optimal operating point.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[1,3]], plotArr[[1,4]], nrow = 1, ncol = 2)
```



* In Fig. \@ref(fig:optim-op-point-froc-froc-10-next-two-plots) panel labeled **10-2**: The vertical blue line is at NLF = `r format(optOpPt[1,1,3], digits = 3)` corresponding to LLF = `r format(optOpPt[1,2,3], digits = 3)`. The end-point of the extended curve is (NLF = `r format(OpPtExtended[1,1,3], digits = 3)`, LLF = `r format(OpPtExtended[1,2,3], digits = 3)`). The highest operating point, that reached when all marks are reported, is at (NLF = `r format(OpPtMax[1,1,3], digits = 3)`, LLF = `r format(OpPtMax[1,2,3], digits = 3)`). 

* In Fig. \@ref(fig:optim-op-point-froc-froc-10-next-two-plots) panel labeled **10-2.5**: The vertical blue line is at NLF = `r format(optOpPt[1,1,4], digits = 3)` corresponding to LLF = `r format(optOpPt[1,2,4], digits = 3)`. The end-point of the extended curve is (NLF = `r format(OpPtExtended[1,1,4], digits = 3)`, LLF = `r format(OpPtExtended[1,2,4], digits = 3)`). The highest operating point, that reached when all marks are reported, is at (NLF = `r format(OpPtMax[1,1,4], digits = 3)`, LLF = `r format(OpPtMax[1,2,4], digits = 3)`). 


* In Fig. \@ref(fig:optim-op-point-froc-froc-10-first-two-plots) panel labeled **10-1**, AUC performance is quite low. In fact AUC = `r maxFomArr[1,1]` (note that we are using the wAFROC FOM, whose minimum value is 0, not 0.5). The optimal operating point of the algorithm is close to the origin, specifically NLF = `r format(optOpPt[1,1,1], digits = 3)` and LLF = `r format(optOpPt[1,2,1], digits = 3)`. Since algorithm performance is so poor, the sensible choice for the algorithm designer is to only show those marks that have, according to the algorithm, very high confidence level for being right (an operating point near the origin corresponds to a high value of $\zeta$). See Fig. \@ref(fig:optim-op-point-froc-2plots) for a demonstration of the effect on wAFROC AUC of showing very few marks (left panel) as compared to showing many (right panel). 



```{r, echo=FALSE}

x1 <- PlotRsmOperatingCharacteristics(mu = c(1, 1), lambda = c(10, 10), nu = c(1, 1), zeta1 = c(3.25, 1.5), lesDistr = lesDistr, relWeights = relWeights, legendPosition = "none")$wAFROC


```


```{r optim-op-point-froc-2plots, fig.cap=" With a poor algorithm it pays to not show too many marks. Shown are wAFROC plots for $\\mu = 1$, $\\lambda = 10$ and $\\nu = 1$. The upper curve corresponds to $\\zeta_1 = 3.25$, the lower to $\\zeta_1 = 1.5$. By reporting fewer marks algorithm performance in the upper plot is visibly improved over that in the lower.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(x1, ncol = 1)
```


* For higher values of $\mu$ shown in Fig. \@ref(fig:optim-op-point-froc-froc-10-first-two-plots) and Fig. \@ref(fig:optim-op-point-froc-froc-10-next-two-plots) -- e.g., panels labeled **10-1.5, 10-2 and 10-2.5** -- AUC performance progressively increases. It now makes sense for the algorithm designer to show marks with lower confidence levels, corresponding to moving up the FROC curve. While it is true that one is also showing more NLs, the increase in the number of LLs compensates -- upto a point -- showing marks beyond the optimal point would result in decreased performance, see for example the plots in Fig. \@ref(fig:optim-op-point-froc-AUC-vs-zeta1-10).


```{r optim-op-point-froc-froc-01-first-two-plots, fig.cap="Extended FROC plots: panel labeled 1-1 is for $\\lambda = 1$ and $\\mu = 1$ and that labeled 10-1.5 is for $\\lambda = 1$ and $\\mu = 1.5$. The blue line indicates the optimal operating point.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[2,1]], plotArr[[2,2]], nrow = 1, ncol = 2)
```             


* In Fig. \@ref(fig:optim-op-point-froc-froc-01-first-two-plots) panel labeled **1-1**: The vertical blue line is at NLF = `r format(optOpPt[2,1,1], digits = 3)` corresponding to LLF = `r format(optOpPt[2,2,1], digits = 3)`. The end-point of the extended curve is (NLF = `r format(OpPtExtended[2,1,1], digits = 3)`, LLF = `r format(OpPtExtended[2,2,1], digits = 3)`). The highest operating point is at (NLF = `r format(OpPtMax[2,1,1], digits = 3)`, LLF = `r format(OpPtMax[2,2,1], digits = 3)`). 

* In Fig. \@ref(fig:optim-op-point-froc-froc-01-first-two-plots) panel labeled **1-1.5**: The vertical blue line is at NLF = `r format(optOpPt[2,1,2], digits = 3)` corresponding to LLF = `r format(optOpPt[2,2,2], digits = 3)`. The end-point of the extended curve is (NLF = `r format(OpPtExtended[2,1,2], digits = 3)`, LLF = `r format(OpPtExtended[2,2,2], digits = 3)`). The highest operating point is at (NLF = `r format(OpPtMax[2,1,2], digits = 3)`, LLF = `r format(OpPtMax[2,2,2], digits = 3)`). 

* It remains to explain the seemingly anomalous behavior seen in the fifth row of Table \@ref(tab:optim-op-point-froc-cad-optim-table) - i.e., NLF peaks at $\mu = 1.5$ and thereafter NLF decreases. The relevant FROC curve is shown in Fig. \@ref(fig:optim-op-point-froc-froc-01-first-two-plots), panel labeled **1-1.5**. The reason is that as $\mu$ increases, the end-point of the FROC keeps moving upwards and to the left, approaching NLF = 0 and LLF = 1 in the limit of infinite $\mu$. Consequently, the expected increase in NLF is cut short or terminated - *one literally runs out of FROC curve to move up on*. Another way of explaining this is that in Fig. \@ref(fig:optim-op-point-froc-froc-01-first-two-plots) panel labeled **1-1** the abscissa of the highest operating point, which equals `r format(OpPtMax[2,1,1], digits = 3)`, is further to the right than in Fig. \@ref(fig:optim-op-point-froc-froc-01-first-two-plots) panel labeled **1-1.5**, where the corresponding abscissa equals `r format(OpPtMax[2,1,2], digits = 3)`. This allows NLF to "access" larger values in Fig. \@ref(fig:optim-op-point-froc-froc-01-first-two-plots) panel labeled **1-1** than in Fig. \@ref(fig:optim-op-point-froc-froc-01-first-two-plots) panel labeled **1-1.5**. Moving to higher values of $\mu$, as in \@ref(fig:optim-op-point-froc-froc-01-next-two-plots) panels labeled **1-2** and **1-2.5**, further illustrates this effect. In the panel labeled **1-2** the maximum abscissa is at `r format(OpPtMax[2,1,3], digits = 3)` while in the panel labeled **1-2.5** the abscissa is at `r format(OpPtMax[2,1,4], digits = 3)`.

* Fig. \@ref(fig:optim-op-point-froc-froc-01-next-two-plots) panel labeled **1-2.5** might help one better understand the need for an optimal operating point. In moving from the optimal abscissa, namely `r format(optOpPt[2,1,4], digits = 3)` to the maximum abscissa `r format(OpPtMax[2,1,4], digits = 3)` one picks ups `r format((OpPtMax[2,2,4] - optOpPt[2,2,4]), digits = 3)` in LLF, a negligible amount compared to the increase in NLF, namely from `r format(optOpPt[2,1,4], digits = 3)` to `r format(OpPtMax[2,1,4], digits = 3)`.


* The explanations in terms of operating points may seem tedious, and indeed they are, which is the reason for choosing a scalar figure of merit, such as the AUC under the wAFROC curve for the optimization. The latter approach obviates convoluted explanations in terms of how much additional or fewer LLs or NLs occur as a result of a change in operating point.


```{r optim-op-point-froc-froc-01-next-two-plots, fig.cap="Extended FROC plots: panel labeled 1-2 is for $\\lambda = 1$ and $\\mu = 2$ and that labeled 1-2.5 is for $\\lambda = 1$ and $\\mu = 2.5$. The blue line indicates the optimal operating point.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[2,3]], plotArr[[2,4]], nrow = 1, ncol = 2)
```



* In Fig. \@ref(fig:optim-op-point-froc-froc-01-next-two-plots) panel labeled **1-2**: The vertical blue line is at NLF = `r format(optOpPt[2,1,3], digits = 3)` corresponding to LLF = `r format(optOpPt[2,2,3], digits = 3)`. The end-point of the extended curve is (NLF = `r format(OpPtExtended[2,1,3], digits = 3)`, LLF = `r format(OpPtExtended[2,2,3], digits = 3)`). The highest operating point is at (NLF = `r format(OpPtMax[2,1,3], digits = 3)`, LLF = `r format(OpPtMax[2,2,3], digits = 3)`). 


* In Fig. \@ref(fig:optim-op-point-froc-froc-01-next-two-plots) panel labeled **1-2.5**: The vertical blue line is at NLF = `r format(optOpPt[2,1,4], digits = 3)` corresponding to LLF = `r format(optOpPt[2,2,4], digits = 3)`. The end-point of the extended curve is (NLF = `r format(OpPtExtended[2,1,4], digits = 3)`, LLF = `r format(OpPtExtended[2,2,4], digits = 3)`). The highest operating point is at (NLF = `r format(OpPtMax[2,1,4], digits = 3)`, LLF = `r format(OpPtMax[2,2,4], digits = 3)`). 



## Using the method {#optim-op-point-froc-how-to-use-method}
Assume that one has designed an algorithmic observer that has been optimized with respect to all other parameters except the reporting threshold. At this point the algorithm reports every suspicious region no matter how low the malignancy index. The mark-rating pairs are entered into a `RJafroc` format Excel input file. The next step is to read the data file -- `DfReadDataFile()` -- convert it to an ROC dataset -- `DfFroc2Roc()` -- and then perform a radiological search model (RSM) fit to the dataset using function `FitRsmRoc()`. This yields the necessary $\lambda, \mu, \nu$ parameters. These values are used to perform the simulations described in the embedded code in this chapter, i.e., that leading to, for example, one of the panels in Fig. \@ref(fig:optim-op-point-froc-AUC-vs-zeta1-01). This determines the optimal reporting threshold: essentially, one scans $\zeta_1$ values looking for maximum in wAFROC AUC -- calculated using `UtilFigureOfMerit()`. This determines the optimal value of $\zeta_1$, namely $\zeta_{\text{max}}$. The RSM parameter values and $\zeta_{\text{max}}$ determine NLF, the optimal reporting point on the FROC curve. The designer sets the algorithm to only report marks with confidence levels exceeding $\zeta_{\text{max}}$.  



## Discussion {#optim-op-point-froc-Discussion}
By selecting the area under the ROC curve one could have performed a similar optimization. One could use this method to select the optimal operating point on the ROC for a radiologist. 

## References {#optim-op-point-froc-references}
