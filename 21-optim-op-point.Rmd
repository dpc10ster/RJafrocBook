# Optimal operating point on FROC {#optim-op-point}

---
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: R/learn/my_header.tex
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval.after = "fig.cap"
)

library(RJafroc)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(abind)
library(dplyr)
```



```{r, echo=FALSE}
OpPtStr <- function(x,y) {
  y <- paste0("(", sprintf("%.3f", x), ", ", sprintf("%.3f", y), ")")
  return(y)
}

simplePrint <- function(x) {
  sprintf("%.3f", x)
}
```



## How much finished {#optim-op-point-how-much-finished}
40%
Major update to 21-optim-op-point.Rmd - need to resolve plots in vary mu





## Methods {#optim-op-point-methods}

The RSM parameters are $\lambda$, $\nu$, $\mu$ and $\zeta_1$. In the following sections each of the first three parameters is varied in turn and the optimal $\zeta_1$ determined by maximizing one of two figures of merit (FOM) namely, the wAFROC-AUC or the Youden-index. The two functions to be minimized, `wAFROC` and `Youden`, are defined next: 

* wAFROC-AUC is computed by `UtilAnalyticalAucsRSM`. Lines 2 - 17 returns `-wAFROC`, the *negative* of wAFROC-AUC. The negative sign is needed because the `optimize()` function, used later, finds the *minimum* of wAFROC-AUC. The first argument is $\zeta_1$, the variable to be varied to find the minimum. The remaining arguments are needed by `UtilAnalyticalAucsRSM`: $\mu$, $\lambda$, $\nu$, `lesDistr` and `relWeights.` The last two specify the number of lesions per case and their weights. The example below uses `lesDistr = c(0.5,0.5)`, i.e., half the abnormal cases contain one lesion and the rest contain two lesions, and `relWeights = c(0.5,0.5)` specifies equal weights.


* The Youden-index is defined as the sum of sensitivity and specificity minus 1. Sensitivity is computed by `RSM_yROC` and specificity by `(1 - RSM_xROC)`. Lines 22 - 40 returns `-Youden`, the *negative* of the Youden-index. 



```{r functions_2be_maximized, echo=TRUE, attr.source = ".numberLines"}

wAFROC <- function (
  zeta1, 
  mu, 
  lambda, 
  nu, 
  lesDistr, 
  relWeights) {
  x <- UtilAnalyticalAucsRSM(
    mu, 
    lambda, 
    nu, zeta1, 
    lesDistr, 
    relWeights)$aucwAFROC
  # return negative of aucwAFROC 
  # (as optimize finds minimum of function)
  return(-x)
  
}


Youden <- function (
  zeta1, 
  mu, 
  lambda, 
  nu, 
  lesDistr, 
  relWeights) {
  # add sensitivity and specificity 
  # and subtract 1, i.e., Youden's index
  x <- RSM_yROC(
    zeta1, 
    mu, 
    lambda, 
    nu, 
    lesDistr) + 
    (1 - RSM_xROC(zeta1, lambda)) - 1
  # return negative of Youden 
  # (as optimize finds minimum of function)
  return(-x)
  
}
```


## Vary lambda  {#optim-op-point-vary-lambda}

For $\mu = 2$ and $\nu = 1$ wAFROC and Youden-index based optimizations were performed for 4 values of $\lambda = 1, 5, 10, 15$. The following quantities were calculated:

* `zetaOptArr`, a [2,4] array, the optimal thresholds $\zeta_1$; 
* `maxFomArr`, a [2,4] array, the optimal values of the figures of merit, wAFROC-AUC or Youden; 
* `rocAucArr`, a [2,4] array, the AUCs under the ROC curves corresponding to optimizations based on wAFROC or Youden-index;   
* `nlfOptArr`, a [2,4] array, the abscissa of the FROC curve corresponding to optimizations based on wAFROC or Youden-index;   
* `llfOptArr`, a [2,4] array, the ordinate of the FROC curve corresponding to optimizations based on wAFROC or Youden-index.   

In each of these arrays the first index `y` denotes whether wAFROC-AUC is being maximized (`y` = 1, see lines 14 - 20) - or if Youden-index is being optimized (`y` = 2, see lines 39 - 45). The second index corresponds to $\lambda$.

```{r optim-op-point-computations-lambda, cache = FALSE, echo=TRUE, attr.source = ".numberLines"}
mu <- 2
nu <- 1
lambdaArr <- c(1,5,10,15)
maxFomArr <- array(dim = c(2,length(lambdaArr)))
zetaOptArr <- array(dim = c(2,length(lambdaArr)))
rocAucArr <- array(dim = c(2,length(lambdaArr)))
nlfOptArr <- array(dim = c(2,length(lambdaArr)))
llfOptArr <- array(dim = c(2,length(lambdaArr)))
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
for (y in 1:2) {
  for (i in 1:length(lambdaArr)) {
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaArr[i], 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaArr[i], 
        nu, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda = lambdaArr[i])
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nu)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaArr[i], 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaArr[i], 
        nu, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda = lambdaArr[i])
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, mu, nu)
    } else stop("incorrect y")
  }
}
```



Table \@ref(tab:optim-op-point-table1) summarizes the results. The column labeled "FOM" shows what is being maximized, "lambda" corresponds to the 4 values of $\lambda$, "zeta1" is the optimal value of $\zeta_1$ that maximizes FOM, "wAFROC" is the wAFROC-AUC, "ROC" is the AUC under the ROC curve, i.e., ROC-AUC, and "OptOpPt" is the optimal operating point on the FROC curve. 

Focusing on the wAFROC-AUC based optimizations (first four rows of table), it is seen that as $\lambda$ increases:

* The optimal threshold $\zeta_1$ increases;
* wAFROC-AUC decreases;
* ROC-AUC decreases;
* The optimal operating point on the FROC moves to lower LLF values, i.e., lower values of lesion-level "sensitivity".

The $\lambda$ Poisson parameter controls the average number of latent non-lesion localizations (NLs or "false-positives") per case. For example, for $\mu = 2$ and $\lambda = 1$, the average number of latent NLs per case is $\lambda' = \lambda /\mu = 0.5$, i.e., an average of one NL every two non-diseased case. With increasing numbers of NLs it is necessary to adopt an increasing reporting threshold in order to not overwhelm the radiologist with NLs, and the price paid is decreasing LLF. Overall CAD performance, regardless of how it is measured, decreases.   

Similar trends are observed for the Youden-index based optimizations (last four rows of table). However, comparing Youden-index based optimizations to wAFROC-AUC based optimizations shows that Youden-index based optimizations yield higher reporting thresholds resulting in lower wAFROC-AUC, lower ROC-AUC and lower LLF values. 




```{r optim-op-point-table1-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), lambda = lambdaArr, zeta1 = simplePrint(zetaOptArr[1,]), wFROC = simplePrint(maxFomArr[1,]), ROC = simplePrint(rocAucArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), lambda = lambdaArr, zeta1 = simplePrint(zetaOptArr[2,]), wFROC = simplePrint(maxFomArr[2,]), ROC = simplePrint(rocAucArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "lambda", "zeta1", "wAFROC", "ROC", "OptOpPt")
```



```{r optim-op-point-table1, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\mu = 2$ and $\\nu = 1$ .", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```



It remains to display the FROC curves with superimposed optimal operating points. One could generate 8 FROC plots, each corresponding to a row of the preceding table, but there is a more efficient method. The FROC curve is defined by the search model parameters as follows:



\begin{equation}
\left. 
\begin{aligned}
NLF \left ( \zeta, \lambda' \right ) =& \lambda' \Phi \left (-\zeta \right ) \\
LLF\left ( \zeta, \mu, \nu', \overrightarrow{f_L} \right ) =& \nu' \Phi \left ( \mu - \zeta \right ) 
\end{aligned}
\right \}
(\#eq:rsm-froc-predictions)
\end{equation}

The *physical* parameters $\lambda'$ and $\nu'$ are related to the *intrinsic* parameters $\mu$, $\lambda$ and $\nu$ by: 

\begin{equation}
\left. 
\begin{aligned}
\lambda' =& \frac{\lambda  }{\mu} \\
\nu' =& 1 - exp\left (-\mu \nu \right ) 
\end{aligned}
\right \}
(\#eq:rsm-intrinsic-physical)
\end{equation}


Since the $\Phi$ function ranges from one to unity, the *four FROC curves are scaled versions of a single curve whose x-axis ranges from 0 to 1*. The single curve corresponds to $\lambda' = 1$ and the true curves are obtained by scaling this curve along the x-axis by the appropriate $\lambda'$ factor. With this understanding one can display 4 FROC curves with a single FROC curve where the x-axis is $NLF \left ( \zeta, \lambda' = 1 \right )$. The true FROC curve is defined by:  



\begin{equation}
\left. 
\begin{aligned}
NLF \left ( \zeta, \lambda' \right ) =& \lambda' NLF \left ( \zeta, \lambda' = 1 \right ) \\
LLF\left ( \zeta, \mu, \nu', \overrightarrow{f_L} \right ) =& \nu' \Phi \left ( \mu - \zeta \right ) 
\end{aligned}
\right \}
(\#eq:rsm-froc-predictions2)
\end{equation}




```{r, attr.source = ".numberLines", echo=FALSE}
scaled_froc <- array(list(), dim = 2)
for (y in 1:2) {
  i <- 1 # no need to generate scaled FROC 4 times
  z <- seq(-5,zetaOptArr[y,i]+5,0.1)
  lambdaP <- lambdaArr[i] / mu
  # scale x-axis to range (0,1) by dividing by lambdaP
  xFROC <- RSM_xFROC(z, mu, lambdaArr[i]) / lambdaP
  yFROC <- RSM_yFROC(z, mu, nu)
  df_scaled_froc <- data.frame(
    NLF_scaled = xFROC, 
    LLF = yFROC)
  scaled_froc[[y]] <- ggplot2::ggplot(
    df_scaled_froc, 
    aes(x = NLF_scaled, y = LLF)) + 
    geom_line() +
    scale_x_continuous(limits = c(0,1)) + 
    scale_y_continuous(limits = c(0,1))
  for ( i in 1:length(lambdaArr)) {
    lambdaP <- lambdaArr[i] / mu
    # scale NLF value by dividing 
    # by lambdaP to match scaling of x-axis
    optPt <- data.frame(
      NLF_scaled = nlfOptArr[y,i] / lambdaP, 
      LLF = llfOptArr[y,i])
    scaled_froc[[y]] <- scaled_froc[[y]] + 
      geom_point(data = optPt, color = i)
  }
}
```




```{r optim-op-point-vary-lambda, fig.cap="Left panel: maximized wAFROC AUC was used to find optimal $\\zeta_1$. Right panel: maximized Youden index was used to find optimal $\\zeta_1$. Dot colors: black means $\\lambda = 1$, red means $\\lambda = 5$, green means $\\lambda = 10$ and blue means $\\lambda = 15$.", fig.show='hold', echo=FALSE}
grid.arrange(scaled_froc[[1]], scaled_froc[[2]], ncol = 2)
```


The left panel in \@ref(fig:optim-op-point-vary-lambda) shows the optimal operating points when wAFROC-AUC is maximized. The 4 operating points are color coded as follows:

* Black dot corresponds to $\lambda = 1$, i.e., $\lambda' = 1/2 = 0.5$. In other words, the true FROC is obtained by *shrinking* the plot, including the superposed black dot, along the x-axis by a factor of 2.  
* Red dot corresponds to $\lambda' = 2.5$. In other words, the true FROC is obtained by *magnifying* that shown, including the red dot, along the x-axis by a factor of 2.5.   
* Green dot corresponds to $\lambda' = 5$. 
* Blue dot corresponds to $\lambda' = 7.5$.  

These plots illustrate the previous comments, namely, as $\lambda$ increases, *the optimal operating point moves down the scaled curve*.

The right panel shows the optimal operating point when the Youden index is maximized. It shows the same general features as the previous example - the optimal operating point moves down the scaled curve - and additionally, the group of four operating points in the right panel are below-left those in the left panel, representing higher values of optimal $\zeta_1$, i.e., a more stringent criteria. 


The FROC curve does not represent true performance. To visualize true performance one compares wAFROC curves, as done below for $\lambda = 1$ and $\lambda = 15$.    



```{r, attr.source = ".numberLines", echo=FALSE}
wafroc <- PlotRsmOperatingCharacteristics(
     c(mu,mu),
     lambdaArr[c(1,4)],
     c(nu,nu),
     zetaOptArr[1,c(1,4)],
     lesDistr,
     relWeights,
     OpChType = "wAFROC",
     legendPosition = "null"
)$wAFROCPlot
```




```{r optim-op-point-vary-lambda-wafroc, fig.cap="Results of wAFROC-AUC based optimizations; wAFROC curves corresponding to $\\lambda = 1$, red curve, and $\\lambda = 15$, blue curve.", fig.show='hold', echo=FALSE}
grid.arrange(wafroc)
```


Only results of wAFROC-AUC based optimizations are shown in \@ref(fig:optim-op-point-vary-lambda-wafroc). The larger area under the red curve, corresponding to the lower value of $\lambda$ is obvious. Each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table1), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,1])` for the red curve and $\zeta_1$ = `r simplePrint(zetaOptArr[1,4])` for the blue curve. The lower performance represented by the blue curve, relative to the red curve, requires the adoption of a higher reporting threshold. For either curve the maximization procedure means that any threshold other than that used would depress performance.



## Vary nu {#optim-op-point-vary-nu}

For $\mu = 2$ and $\lambda= 5$ wAFROC and Youden-index based optimizations were performed for 4 values of $\nu = 0.1,0.5,1,2$. Table \@ref(tab:optim-op-point-table2) summarizes the results. 




```{r optim-op-point-computations-nu, cache = FALSE, echo=FALSE}
mu <- 2
lambda <- 5
nuArr <- c(0.1,0.5,1,2)
maxFomArr <- array(dim = c(2,length(nuArr)))
zetaOptArr <- array(dim = c(2,length(nuArr)))
rocAucArr <- array(dim = c(2,length(nuArr)))
nlfOptArr <- array(dim = c(2,length(nuArr)))
llfOptArr <- array(dim = c(2,length(nuArr)))
for (y in 1:2) {
  for (i in 1:length(nuArr)) {
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambda, 
                    nuArr[i], 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambda, 
        nuArr[i], 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nuArr[i])
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambda, 
                    nuArr[i], 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambda, 
        nuArr[i], 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        mu, 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nu = nuArr[i])
    } else stop("incorrect y")
  }
}
```






```{r optim-op-point-table2-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), nu = nuArr, zeta1 = simplePrint(zetaOptArr[1,]), wFROC = simplePrint(maxFomArr[1,]), ROC = simplePrint(rocAucArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), nu = nuArr, zeta1 = simplePrint(zetaOptArr[2,]), wFROC = simplePrint(maxFomArr[2,]), ROC = simplePrint(rocAucArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "nu", "zeta1", "wAFROC", "ROC", "OptOpPt")
```



```{r optim-op-point-table2, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\mu = 2$ and $\\lambda = 5$ .", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```


The effect of increasing $\nu$ is to cause the optimal operationg point to move up the FROC curve: it is opposite to the effect of increasing $\lambda$. Focusing on the wAFROC-AUC based optimizations (first four rows of table), it is seen that as $\nu$ increases:

* The optimal threshold $\zeta_1$ decreases, resulting in more marks being reported;
* wAFROC-AUC increases;
* ROC-AUC increases;
* The optimal operating point on the FROC moves to higher LLF values, i.e., higher values of lesion-level "sensitivity".

The $\nu$ binomial parameter controls the average fraction of latent lesion localizations (LLs or "true-positives") per diseased case. For example, for $\mu = 2$ and $\nu = 0.1$, the fraction is $\nu' = 1 - \exp(-\mu \nu) = 0.1813$, i.e., an average of 18 percent of lesions present are seen by CAD at confidence level $ > -\infty$. Overall CAD performance increases with increasing $\nu$.   

Comparing Youden-index based optimizations (last four rows of table) to wAFROC-AUC based optimizations shows that the former yields higher reporting thresholds, lower wAFROC-AUC, lower ROC-AUC and lower LLF values. 




```{r, echo=FALSE}
froc <- array(list(), dim = c(2))
for (y in 1:2) {
  froc[[y]] <- ggplot2::ggplot()
  for ( i in 1:length(nuArr)) {
    z <- seq(-5,zetaOptArr[y,i]+5,0.1)
    xFROC <- RSM_xFROC(z, mu, lambda)
    yFROC <- RSM_yFROC(z, mu, nuArr[i]) 
    df_froc <- data.frame(NLF = xFROC, LLF = yFROC)
    froc[[y]] <- froc[[y]] + 
      geom_line(data = df_froc, aes(x = NLF, y = LLF))
    optPt <- data.frame(
      NLF = nlfOptArr[y,i], 
      LLF = llfOptArr[y,i]) 
    froc[[y]] <- froc[[y]] + 
      geom_point(data = optPt, 
                 aes(x = NLF, y = LLF),  
                 color = i)
  }
}
```




```{r optim-op-point-vary-nu, fig.cap="Left panel: maximized wAFROC AUC was used to find optimal $\\zeta_1$. Right panel: maximized Youden index was used to find optimal $\\zeta_1$. Dot colors: black means $\\nu = 0.1$, red means $\\nu = 0.5$, green means $\\nu = 1$ and blue means $\\nu = 2$.", fig.show='hold', echo=FALSE}
grid.arrange(froc[[1]], froc[[2]], ncol = 2)
```


Fig. \@ref(fig:optim-op-point-vary-nu) shows the FROC curves with optimal operating points superimposed. The left panel corresponds to wAFROC-AUC based optimizations while the right panel corresponds to Youden-index based optimizations. These illustrate the previous comments, namely, as $\nu$ increases, *the optimal operating point moves up the FROC curve*.


To visualize true performance one compares wAFROC curves as done in Fig. \@ref(fig:optim-op-point-vary-mu-wafroc) for  $\nu = 0.1$ and $\nu = 2$.    



```{r, echo=FALSE}
wafroc <- PlotRsmOperatingCharacteristics(
     c(mu,mu),
     c(lambda,lambda),
     nuArr[c(1,4)],
     zetaOptArr[1,c(1,4)],
     lesDistr,
     relWeights,
     OpChType = "wAFROC",
     legendPosition = "null"
)$wAFROCPlot
```


```{r optim-op-point-vary-nu-wafroc, fig.cap="Results of wAFROC-AUC based optimizations; wAFROC curves corresponding to $\\nu = 0.1$, red curve, and $\\nu = 2$, blue curve.", fig.show='hold', echo=FALSE}
grid.arrange(wafroc)
```


The larger area under the red curve, corresponding to the lower value of $\nu$, is obvious. Each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table2), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,1])` for the red curve and $\zeta_1$ = `r simplePrint(zetaOptArr[1,4])` for the blue curve. The lower performance represented by the red curve requires the adoption of a higher reporting threshold. 





## Vary mu {#optim-op-point-vary-mu}

For $\nu = 1$ and $\lambda= 1$ wAFROC and Youden-index based optimizations were performed for 4 values of $\mu = 0.75,1,1.25,1.5$. Table \@ref(tab:optim-op-point-table2) summarizes the results.  



```{r optim-op-point-computations-mu, cache = FALSE, echo=FALSE}
nu <- 1
lambda <- 1
muArr <- c(0.75,1,1.25,1.5)
maxFomArr <- array(dim = c(2,length(muArr)))
zetaOptArr <- array(dim = c(2,length(muArr)))
rocAucArr <- array(dim = c(2,length(muArr)))
nlfOptArr <- array(dim = c(2,length(muArr)))
llfOptArr <- array(dim = c(2,length(muArr)))
for (y in 1:2) {
  for (i in 1:length(muArr)) {
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    muArr[i], 
                    lambda, 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        muArr[i], 
        lambda, 
        nu, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        muArr[i], 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        muArr[i], 
        nu)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    muArr[i], 
                    lambda, 
                    nu, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      maxFomArr[y,i] <- -x$objective
      rocAucArr[y,i] <- UtilAnalyticalAucsRSM(
        muArr[i], 
        lambda, 
        nu, zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        muArr[i], 
        lambda)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        muArr[i], 
        nu)
    } else stop("incorrect y")
  }
}
```






```{r optim-op-point-table3-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), mu = muArr, zeta1 = simplePrint(zetaOptArr[1,]), wFROC = simplePrint(maxFomArr[1,]), ROC = simplePrint(rocAucArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), mu = muArr, zeta1 = simplePrint(zetaOptArr[2,]), wFROC = simplePrint(maxFomArr[2,]), ROC = simplePrint(rocAucArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "mu", "zeta1", "wAFROC", "ROC", "OptOpPt")
```



```{r optim-op-point-table3, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\nu = 1$ and $\\lambda = 1$ .", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```



* From Table \@ref(tab:optim-op-point-table3) for the lowest value $\mu = 0.75$ the end-point of the FROC, corresponding to $\zeta_1 = -\infty$, is the farthest to the right and lowest in the vertical direction, and the optimal operating point is closest to the origin, i.e., `r OpPtStr(nlfOptArr[1,1], llfOptArr[1,1])`. wAFROC-AUC performance = `r simplePrint(maxFomArr[1,1])` is least as is ROC-AUC = `r simplePrint(rocAucArr[1,1])`. ^[With even lower performance - achieved by choosing, for example, a smaller value of $\mu$, both wAFROC and ROC AUCs approach 0.5 and the optimal operating point is at the origin - basically the algorithm is so poor that none of its marks should be shown to the radiologist.] 

* As $\mu$ increases, the FROC end-point moves to the upper left and the optimal operating point moves up.

* At the highest value $\mu = 1.5$ the end-point of the FROC is the closest to (0,1), and the optimal operating point is farthest from the origin, i.e., `r OpPtStr(nlfOptArr[1,4], llfOptArr[1,4])`. wAFROC-AUC performance = `r simplePrint(maxFomArr[1,4])` is greatest as is ROC-AUC = `r simplePrint(rocAucArr[1,4])`. With good performance one shows lower confidence level marks: $\zeta_1$ = `r simplePrint(zetaOptArr[1,4])` than is possible with poorer performance. With even higher values of $\mu$ both wAFROC and ROC AUCs approach 1 and the optimal operating point approaches (0,1) - the algorithm is so good that all of its marks should be shown to the radiologist. 

* At the lowest value $\mu = 0.75$ the end-point of the FROC is at `r OpPtStr(nlfOptArr[2,1], llfOptArr[2,1])`. wAFROC-AUC performance = `r simplePrint(maxFomArr[2,1])` and ROC-AUC = `r simplePrint(rocAucArr[2,1])`, both of which are smaller than the values obtained using wAFROC-AUC maximization. 

* At the highest value $\mu = 1.5$ the end-point of the FROC at `r OpPtStr(nlfOptArr[2,4], llfOptArr[2,4])`. wAFROC-AUC performance = `r simplePrint(maxFomArr[2,4])` and ROC-AUC = `r simplePrint(rocAucArr[2,4])`, both of which are smaller that the values obtained using wAFROC-AUC maximization. 

* TBA With one exception the operating points in the right panel are below-left (i.e., represent higher thresholds) those in the left panel. The Youden-index based optimization yields stricter reporting threshold. Somewhat paradoxically, for the lowest value of $\mu$ the method predicts a lenient threshold.  





```{r, echo=FALSE}
froc <- array(list(), dim = c(2))
for (y in 1:2) {
  froc[[y]] <- ggplot2::ggplot()
  for ( i in 1:length(muArr)) {
    z <- seq(-5,zetaOptArr[y,i]+5,0.1)
    xFROC <- RSM_xFROC(z, muArr[i], lambda)
    yFROC <- RSM_yFROC(z, muArr[i], nu) 
    df_froc <- data.frame(NLF = xFROC, LLF = yFROC)
    froc[[y]] <- froc[[y]] + 
      geom_line(data = df_froc, aes(x = NLF, y = LLF))
    optPt <- data.frame(
      NLF = nlfOptArr[y,i], 
      LLF = llfOptArr[y,i]) 
    froc[[y]] <- froc[[y]] + 
      geom_point(data = optPt, 
                 aes(x = NLF, y = LLF),  
                 color = i)
  }
}
```



Fig. \@ref(fig:optim-op-point-vary-mu) shows FROC curves with superimposed optimal operating points. 


```{r optim-op-point-vary-mu, fig.cap="Left panel: maximized wAFROC AUC was used to find optimal $\\zeta_1$. Right panel: maximized Youden-index was used to find optimal $\\zeta_1$. Dot colors: black means $\\mu = 0.75$, red means $\\mu = 1$, green means $\\lambda = 1.25$ and blue means $\\mu = 1.5$.", fig.show='hold', echo=FALSE}
grid.arrange(froc[[1]], froc[[2]], ncol = 2)
```


For each of the four values of $\mu$ the left panel in Fig. \@ref(fig:optim-op-point-vary-mu) shows the optimal operating point when wAFROC-AUC is maximized. It shows the FROC curves with optimal operating points superimposed. These illustrate the previous comments, namely, as $\mu$ increases, *the optimal operating point moves up the FROC curve*.



The right panel in Fig. \@ref(fig:optim-op-point-vary-mu) shows the optimal operating point when the Youden-index is maximized. 



To visualize true performance one compares wAFROC curves as done in Fig. \@ref(fig:optim-op-point-vary-mu-wafroc) for $\mu = 0.75$ and $\mu = 1.5$.    



```{r, echo=FALSE}
wafroc <- PlotRsmOperatingCharacteristics(
     c(mu,mu),
     c(lambda,lambda),
     nuArr[c(1,4)],
     zetaOptArr[1,c(1,4)],
     lesDistr,
     relWeights,
     OpChType = "wAFROC",
     legendPosition = "null"
)$wAFROCPlot
```


```{r optim-op-point-vary-mu-wafroc, fig.cap="Results of wAFROC-AUC based optimizations; wAFROC curves corresponding to $\\mu = 0.75$, red curve, and $\\mu = 1.5$, blue curve.", fig.show='hold', echo=FALSE}
grid.arrange(wafroc)
```


The larger area under the blue curve, corresponding to the greater value of $\mu$, is obvious. Each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table3), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,1])` for the red curve and $\zeta_1$ = `r simplePrint(zetaOptArr[1,4])` for the blue curve. The lower performance represented by the red curve requires the adoption of a higher reporting threshold. 






## References {#optim-op-point-references}
