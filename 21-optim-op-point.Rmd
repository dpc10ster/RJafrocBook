# Optimal operating point on FROC {#optim-op-point}

---
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: R/learn/my_header.tex
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval.after = "fig.cap"
)

library(RJafroc)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(abind)
library(dplyr)
```



```{r}
OpPtStr <- function(x,y) {
  y <- paste0("(", sprintf("%.3f", x), ", ", sprintf("%.3f", y), ")")
  return(y)
}
```



## How much finished {#optim-op-point-how-much-finished}
70%


## Introduction {#optim-op-point-intro}
A CAD system yields FROC mark-rating data where the (continuous scale) ratings generated by the algorithm are available to the algorithm designer with the understanding that only marks with ratings exceeding a pre-selected threshold are to be displayed (or reported) to the radiologist. The problem addressed in this chapter is how to select the optimal reporting threshold.

TBA: literature review

It is assumed that *the optimal reporting threshold $\zeta_{\text{max}}$ is that value of $\zeta_1$ that maximizes the area under curve (AUC) of an appropriately selected operating characteristic*. This chapter examines the effect of changing the reporting threshold $\zeta_1$ on the area under curve for (a) the receiver operating characteristic (ROC) and (b) the weighted alternative free-response receiver operating characteristic (wAFROC).

TBA Summarize the sections that follow.

## Dependence of ROC performance on threshold {#optim-op-point-dependence-threshold-roc}
It is clear that moving the reporting threshold $\zeta_1$ along the ROC curve does not change the *total* area under the ROC curve. This was the reason, Chapter TBA, for preferring, as a figure of merit, the area under curve under the full curve in lieu of reported sensitivity-specificity pairs. One might incorrectly assume that this means that performance is independent of reporting threshold. When $\zeta_1 = -\infty$ then performance, represented by the area $\text{area under curve}$ under the full continuous curve shown below (left plot), is indeed independent of reporting threshold (trivially, because the latter is constant at $-\infty$). However, if the observer adopts a finite reporting threshold $\zeta_1$ then the ROC curve stops at an operating point, see Fig. \@ref(fig:optim-op-point-dependence-threshold-roc-plot1) -- solid dot, left plot -- that is below-left of (1,1). *Net performance, represented by the area under the continuous section up to the solid dot plus the area under the dashed line in the left plot*, is denoted $\text{area under curve}(\zeta_1)$, which depends on $\zeta_1$. It is clear from the left plot that $\text{area under curve}(\zeta_1) \le \text{area under curve}$. The left plot also demonstrates that $\text{area under curve}(\zeta_1)$ as a function of $\zeta_1$ has a maximum at $\zeta_1 = -\infty$. In other words, using the ROC figure of merit, performance of the CAD algorithm is maximized by displaying *all* the marks. 

The restriction above to the left plot is because it is (almost) a proper ROC curve ^[whenever $b \ne 1$ the binormal ROC curve is improper, although the "hook" may not be readily visible under normal plotting conditions.]. For a proper ROC curve the slope decreases continuously as one moves up the plot. This ensures that the continuous section to the right of the solid dot in the left plot is always *above* the dashed line. The right plot in see Fig. \@ref(fig:optim-op-point-dependence-threshold-roc-plot1) corresponding to $a = 1$ and $b = 0.2$, illustrates the situation when the curve is visibly improper. Now the dashed line is mostly above the continuous section and performance is maximized at a finite value of $\zeta_1$: an invalid conclusion due to the fact that an improper ROC curve is a fitting artifact of the binormal model.  

```{r echo=FALSE}
a <- 2; b <- 0.8; zeta1Arr <- seq(1.5,5.5,0.05)
zeta1ArrAll <- seq(-3,5.5,0.05)
FPF <- pnorm(-zeta1Arr)
TPF <- pnorm(a - b*zeta1Arr)
#truncated <- data.frame(FPF = FPF, TPF = TPF)
continuous <- data.frame(FPF = pnorm(-zeta1ArrAll), TPF = pnorm(a - b*zeta1ArrAll))
dashed <- data.frame(FPF = c(FPF[1], 1), TPF = c(TPF[1], 1))
endPoint <- data.frame(x = FPF[1], y = TPF[1])
p1 <- ggplot2::ggplot(continuous, aes(x = FPF, y = TPF)) + 
  geom_line() + 
  geom_line(data = dashed, aes(x = FPF, y = TPF), linetype = 3) + 
  geom_point(data = endPoint, aes(x = x, y = y), size = 4) + 
  scale_x_continuous(limits = c(0,1)) + scale_y_continuous(limits = c(0,1))
```



```{r echo=FALSE}
a <- 1; b <- 0.2; zeta1Arr <- seq(1.5,5.5,0.05)
zeta1ArrAll <- seq(-10,15,0.05)
FPF <- pnorm(-zeta1Arr)
TPF <- pnorm(a - b*zeta1Arr)
#truncated <- data.frame(FPF = FPF, TPF = TPF)
continuous <- data.frame(FPF = pnorm(-zeta1ArrAll), TPF = pnorm(a - b*zeta1ArrAll))
dashed <- data.frame(FPF = c(FPF[1], 1), TPF = c(TPF[1], 1))
endPoint <- data.frame(x = FPF[1], y = TPF[1])
p2 <- ggplot2::ggplot(continuous, aes(x = FPF, y = TPF)) + 
  geom_line() + 
  geom_line(data = dashed, aes(x = FPF, y = TPF), linetype = 3) + 
  geom_point(data = endPoint, aes(x = x, y = y), size = 4) + 
  scale_x_continuous(limits = c(0,1)) + scale_y_continuous(limits = c(0,1))
```



```{r optim-op-point-dependence-threshold-roc-plot1, fig.cap="Left plot: almost proper binormal ROC curve corresponding to a = 2 and b = 0.8. The solid dot is the operating point corresponding to $\\zeta_1 = 1.5$. The solid curve corresponds to $\\zeta_1 = -\\infty$. Note that the solid curve is above the dashed line. Right plot: improper binormal ROC curve corresponding to a = 1 and b = 0.2. The solid curve is below the dashed line.", fig.show='hold', echo=FALSE}
grid.arrange(p1, p2, ncol = 2)
```


## Dependence of FROC performance on threshold {#optim-op-point-dependence-threshold-wafroc}
The situation is different if one uses the wAFROC figure of merit. Consider the three wAFROC plots shown in see Fig. \@ref(fig:optim-op-point-dependence-threshold-wafroc-plot). These correspond to $\mu = 2$, $\lambda = 5$, $\nu = 1$, one lesion per case, and values of $\zeta_1$, from left to right: $\zeta_1 = 2$, $\zeta_1 = 1$ and $\zeta_1 = -1$. The area under the wAFROC curve in the middle plot is actually greater than that for the plots on either side of it, a fact that be difficult to appreciate, but is brought out more clearly in the next plot.  

```{r, echo=FALSE}
mu <- 2
lambda <- 5
nu <- 1
L <- 1
zeta1 <- 2
lesDistr <- c(rep(0, L-1), 1)
ret1 <- PlotRsmOperatingCharacteristics(
  mu, lambda, nu, zeta1, 
  lesDistr = L, legendPosition  = "none",
  llfRange = c(0,1)
)
p1 <- ret1$wAFROCPlot
```


```{r, echo=FALSE}
zeta1 <- 1
ret1 <- PlotRsmOperatingCharacteristics(
  mu, lambda, nu, zeta1, 
  lesDistr = L, legendPosition  = "none",
  llfRange = c(0,1)
)
p2 <- ret1$wAFROCPlot
```



```{r, echo=FALSE}
zeta1 <- -1
ret1 <- PlotRsmOperatingCharacteristics(
  mu, lambda, nu, zeta1, 
  lesDistr = L, legendPosition  = "none",
  llfRange = c(0,1)
)
p3 <- ret1$wAFROCPlot
```



```{r optim-op-point-dependence-threshold-wafroc-plot, fig.cap="Left plot: wAFROC curve for $\\zeta_1 = 2$; Middle plot: wAFROC curve for $\\zeta_1 = 1$; Right plot: wAFROC curve for $\\zeta_1 = -1$. The middle curve has the highest area under the curve. This fact is made clearer in the next figure.", fig.show='hold', echo=FALSE}
grid.arrange(p1, p2, p3, ncol = 3)
```


The next plot, see Fig. \@ref(fig:optim-op-point-dependence-threshold-wafroc-plot2), in which three previous plots are superposed, shows the differences in areas more clearly. The green plot (solid green line plus the dashed green line), corresponding to $\zeta_1 = 2$, clearly has the least area. The "green-red" plot (i.e., the solid green line plus the solid red line plus the dashed red line), corresponding to $\zeta_1 = 1$, has the greatest area. The "green-red-blue" plot (i.e., the solid green line plus the solid red line plus the solid blue line plus the dashed blue line), corresponding to $\zeta_1 = -1$, has slightly smaller area than that of the "green-red" plot. There is a maximum in area under the wAFROC curve near $\zeta_1 = 1$. A more precise determination of the optimal value of $\zeta_1$, using numerical search, will be shown later, but it is clear a maximum exists and that it does not correspond to $\zeta_1 = -\infty$, in other words it does not correspond to showing all the marks, as was the case when one used the ROC operating characteristic. 

The essential difference between the ROC and the wAFROC examples is this: as one moves up the proper ROC curve, the slope decreases monotonically and the curve ends at (1,1) while the wAFROC curve has monotonically decreasing slope but it ends at a point below-left to (1,1): the wAFROC somewhat resembles an improper ROC but this time it is not a fitting artifact. *The geometrical difference in the shape of the two curves enables a finite and meaningful optimal $\zeta_1$ for the wAFROC but not for the ROC*.

In the following sections the optimal operating point determined using the wAFROC curve will be explored for two algorithmic observer, one with low performance and one with performance similar to an expert radiologist. Since CAD developers are more familiar with FROC curves than wAFROC curves, the optimal operating points for the two algorithms will be illustrated using FROC curves. 



```{r, echo=FALSE}
df1 <- data.frame(FPF = p1$data$FPF, wLLF = p1$data$wLLF)

endPoint1 <- data.frame(FPF = p1$data$FPF[1], wLLF = p1$data$wLLF[1])
section2 <- which(p2$data$FPF >= endPoint1$FPF)
df2 <- data.frame(FPF = p2$data$FPF[section2], 
                  wLLF = p2$data$wLLF[section2])

endPoint2 <- data.frame(FPF = p2$data$FPF[1], wLLF = p2$data$wLLF[1])
section3 <- which(p3$data$FPF >= endPoint2$FPF)
df3 <- data.frame(FPF = p3$data$FPF[section3], 
                  wLLF = p3$data$wLLF[section3])

endPoint3 <- data.frame(FPF = p3$data$FPF[1], wLLF = p3$data$wLLF[1])
dashed1 <- data.frame(FPF = c(p1$data$FPF[1], 1), wLLF = c(p1$data$wLLF[1], 1))
dashed2 <- data.frame(FPF = c(p2$data$FPF[1], 1), wLLF = c(p2$data$wLLF[1], 1))
dashed3 <- data.frame(FPF = c(p3$data$FPF[1], 1), wLLF = c(p3$data$wLLF[1], 1))
p <- ggplot2::ggplot(data = df1, aes(x = FPF, y = wLLF)) + 
  geom_line(color = "green3") + 
  geom_point(data = endPoint1, size = 3, color = "green3") + 
  geom_line(data = dashed1, aes(x = FPF, y = wLLF), linetype = 3, color = "green3") + 
  geom_line(data = df2, color = "red") + 
  geom_point(data = endPoint2, size = 3, color = "red") + 
  geom_line(data = dashed2, aes(x = FPF, y = wLLF), linetype = 3, color = "red") + 
  geom_line(data = df3, color = "blue") + 
  geom_point(data = endPoint3, size = 3, color = "blue") + 
  geom_line(data = dashed3, aes(x = FPF, y = wLLF), linetype = 3, color = "blue") + 
  scale_x_continuous(limits = c(0,1)) + scale_y_continuous(limits = c(0,1))
```


```{r optim-op-point-dependence-threshold-wafroc-plot2, fig.cap="The green curve corresponds to $\\zeta_1 = 2$, the green+red curve corresponds to $\\zeta_1 = 1$ and the green+red+blue curve corresponds to $\\zeta_1 = -1$. The green+red curve plus the red dashed line extension has the greatest area under the wAFROC, corresponding to being near the optimal choice of threshold. Note that each area includes that under the corresponding dashed line.", fig.show='hold', echo=FALSE}
grid.arrange(p)
```



```{r do_one_mu, echo=FALSE}
do_one_mu <- function(mu, lambda, nu, zeta1Arr, lesDistr, relWeights) {

  fomArray <- array(dim = length(zeta1Arr))
  for (i1 in 1:length(zeta1Arr)) {
    fomArray[i1] <- UtilAnalyticalAucsRSM(mu, lambda, nu, zeta1 = zeta1Arr[i1], lesDistr, relWeights)$aucwAFROC
  }
  # generate plot of area under curve vs. zeta1
  myData <- data.frame(zeta1 = zeta1Arr, AUC = fomArray)
  p <- ggplot2::ggplot(myData, aes(x = zeta1, y = AUC)) + geom_line()
  zetaMax <- zeta1Arr[which.max(fomArray)]
  return(list(
    p = p,
    zetaMax = zetaMax,
    maxFom = fomArray[which.max(fomArray)]
  ))
}
```

## Methods {#optim-op-point-methods}

Two values of the $\lambda$ parameter were used: $\lambda = 10$ and $\lambda = 1$. For each $\lambda$ two value of $\mu$ were used: $\mu = 1$ and $\mu = 2$. The $\nu$ parameter was held constant at $\nu = 1$. Diseased cases with one or two lesions occurring with equal probability (`lesDistr` in following code) and equally weighted lesions were assumed (`relWeights`). 

$\lambda = 10$ characterizes a CAD system that generates about 10 times the number of latent NL marks as an expert radiologist, while $\lambda = 1$ characterizes a CAD system that generates about the same number of latent NL marks as an expert radiologist. Performance improves with increasing $\mu$ and decreasing $\lambda$. 

For each $(\lambda,\mu)$ pair a range of values of $\zeta_1$ was scanned. For each $\zeta_1$ the area under the wAFROC curve was calculated using function `UtilAnalyticalAucsRSM()`. This function returns the wAFROC area under curve. The procedure for different values of $\zeta_1$ to find the value of $\zeta_1$  -- denoted $\zeta_{\text{max}}$ -- that maximized the area under curve. The corresponding (NLF,LLF) values on the FROC curve and the optimal wAFROC area under curve were recorded. 

Shown next is the variation of wAFROC area under curve vs. $\zeta_1$ for $\lambda = 10$ and the two values of the $\mu$ parameter.


### $\zeta_1$ optimization for $\lambda = 10$

```{r maxFomArr_10, cache = FALSE, echo=TRUE}
# determine plotArr[[1,]], zetaMaxArr[1,] and maxFomArr[1,]
lambda <- 10
nu <- 1
mu_arr <- c(1, 2)
maxFomArr <- array(dim = c(2,length(mu_arr)))
zetaMaxArr <- array(dim = c(2, length(mu_arr)))
plotArr <- array(list(), dim = c(2, length(mu_arr)))
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
for (i in 1:length(mu_arr)) {
  if (i == 1) zeta1Arr <- seq(1.5,3.5,0.05) else zeta1Arr <- seq(0.5,2.5,0.1)
  x <- do_one_mu (mu_arr[i], lambda, nu, zeta1Arr, lesDistr, relWeights)
  plotArr[[1,i]] <- x$p + 
    ggtitle(paste0("mu = ", 
                   as.character(mu_arr[i]), 
                   ", zetaMax = ", 
                   format(x$zetaMax, digits = 3)))
  zetaMaxArr[1,i] <- x$zetaMax
  maxFomArr[1,i] <- x$maxFom
  # plotArr[[2,i]] etc. reserved for lambda = 1 results, done later
}
```


In the above code `plotArr` contains the plots (`x$p` plus a title string) of wAFROC area under curve vs. $\zeta_1$, `zetaMaxArr` contains the value of $\zeta_1$ that maximizes wAFROC area under curve (`x$zetaMax`) and `maxFomArr` contains the maximum value of wAFROC (`x$maxFom`). The first dimension of the arrays is reserved for the two values of $\lambda$, the second for the two values of $\mu$. 


```{r optim-op-point-auc-vs-zeta1-10, fig.cap="Variation of area under curve vs. $\\zeta_1$ for $\\lambda = 10$; AUC is the wAFROC area under curve. Panels are labeled by the values of $\\mu$ and $\\zeta_{\\text{max}}$. For $\\mu = 1$ there is a broad maximum but for $\\mu = 2$ it is better defined.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1,1]],plotArr[[1,2]], ncol = 2)
```


Shown next is the variation of wAFROC area under curve vs. $\zeta_1$ for $\lambda = 1$ and the two values of the $\mu$ parameter.


### $\zeta_1$ optimization for $\lambda = 1$

```{r maxFomArr_01, cache = FALSE, echo=FALSE}
# determine plotArr[[2,]], zetaMaxArr[2,] and maxFomArr[2,]
lambda <- 1

for (i in 1:length(mu_arr)) {
  zeta1Arr <- seq(-1,1,0.05)
  fomArray <- array(dim = length(zeta1Arr))
  x <- do_one_mu (mu_arr[i], lambda, nu, zeta1Arr, lesDistr, relWeights)
  plotArr[[2,i]] <- x$p + ggtitle(paste0("mu = ", as.character(mu_arr[i]), ", zetaMax = ",  format(x$zetaMax, digits = 3)))
  zetaMaxArr[2,i] <- x$zetaMax
  maxFomArr[2,i] <- x$maxFom
}
```



```{r optim-op-point-auc-vs-zeta1-01, fig.cap="Variation of area under curve vs. $\\zeta_1$ for $\\lambda = 1$.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[2,1]],plotArr[[2,2]], ncol = 2)
```

Fig. \@ref(fig:optim-op-point-auc-vs-zeta1-01) corresponds to $\lambda = 1$ and employs a similar labeling scheme as Fig. \@ref(fig:optim-op-point-auc-vs-zeta1-10). For example, the panel labeled `mu = 1, zetaMax = 0.3` shows that area under curve has a maximum at $\zeta_1 = 0.3$. 



```{r do_one_froc, echo=FALSE}
do_one_froc <- function(mu, lambda, nu, zeta1, lesDistr, relWeights, llfRange) {
  
  
  froc <- PlotRsmOperatingCharacteristics(
    mu, 
    lambda, 
    nu, 
    zeta1, 
    lesDistr = lesDistr, 
    relWeights = relWeights, 
    OpChType = "FROC",
    llfRange = llfRange,
    legendPosition = "none")$FROCPlot
  
  return(froc)
}
```



```{r detOptOpPt, cache = FALSE, echo=FALSE}
# determine optOpPt here

lambdaArr <- c(10,1)
nu <- 1
#mu_arr <- c(1, 1.5, 2, 2.5) #already defined above
#zetaMaxArr                  #already defined above
#plotArr <- array(list(), dim = c(2,length(mu_arr)))

# indices: lambda, nlf/llf, 2-values of mu
OpPtMax <- optOpPt <- array(dim = c(2, 2, 2))

for (j in 1:2) {
  for (i in 1:length(mu_arr)) {
    if ((j ==1) && (i ==1)) llfRange <- c(0, 0.1) else llfRange <- c(0,1) 
    x <- do_one_froc (mu_arr[i],
                      lambdaArr[j],
                      nu,
                      zeta1 = zetaMaxArr[j,i],
                      lesDistr, 
                      relWeights, 
                      llfRange)
    # optimal operating point
    optOpPt[j,1,i] <- max(x$data$NLF)
    optOpPt[j,2,i] <- max(x$data$LLF)
    
    # following are end-points assuming zeta1 = -Inf
    physicalValues <- UtilIntrinsic2PhysicalRSM(mu_arr[i], lambdaArr[j], nu)
    # OpPtMax[j,1,i] <- physicalValues$lambdaP*pnorm(-zetaMaxArr[j,i])
    # OpPtMax[j,2,i] <- physicalValues$nuP*pnorm(mu_arr[i]-zetaMaxArr[j,i])
    OpPtMax[j,1,i] <- physicalValues$lambdaP
    OpPtMax[j,2,i] <- physicalValues$nuP
  }
}
```



```{r useOptOpPt, cache = FALSE, echo=FALSE}

# use optOpPt here
# generate plotArr

lambdaArr <- c(10,1)
nu <- 1
# following are coordinates of extended plots
OpPtExtended <- array(dim = c(2, 2, 4))
# optOpPt defined above
#mu_arr <- c(1, 1.5, 2, 2.5) #already defined above
#zetaMaxArr                  #already defined above
plotArr <- array(list(), dim = c(2,length(mu_arr)))

correction <- array(0.5, dim = c(2, 4))

for (j in 1:2) {
  for (i in 1:length(mu_arr)) {
    if ((j ==1) && (i ==1)) llfRange <- c(0, 0.1) else llfRange <- c(0,1) 
    x <- do_one_froc (
      mu_arr[i],
      lambdaArr[j],
      nu,
      # to show a fuller extent of the plot
      zeta1 = zetaMaxArr[j,i] - correction[j,i],
      lesDistr,
      relWeights, 
      llfRange)

    plotArr[[j,i]] <- x +
      geom_vline(
        xintercept =
          optOpPt[j,1,i], color = "blue")  +
      ggtitle(
        paste0(
          as.character(lambdaArr[j]),
          "-",
          as.character(mu_arr[i])))

    OpPtExtended[j,1,i] <- max(x$data$NLF)
    OpPtExtended[j,2,i] <- max(x$data$LLF)
  }
}
```



```{r optim-op-point-cad-optim-zeta1, echo=FALSE}
x1 <- rbind(sprintf( "%.3f", t(maxFomArr[1,]), digits = 3), sprintf( "%.3f", t(maxFomArr[2,]), digits = 3))
x2 <- cbind(OpPtStr(optOpPt[1,1,1], optOpPt[1,2,1]), OpPtStr(optOpPt[1,1,2], optOpPt[1,2,2]))
x3 <- cbind(OpPtStr(optOpPt[2,1,1], optOpPt[2,2,1]), OpPtStr(optOpPt[2,1,2], optOpPt[2,2,2]))
x123 <- as.data.frame(rbind(x1, x2, x3))
x123 <- cbind(c("AUC", "AUC", "(NLF, LLF)", "(NLF, LLF)"), x123)
x123 <- cbind(c(10, 1, 10, 1), x123)
colnames(x123) <- c("Lambda", "Measure", paste0("mu = ", as.character(mu_arr)))
```


### Summary of optimization results {#optim-op-point-comments-threshold-optimization}


```{r optim-op-point-cad-optim-table, echo=FALSE}
kbl(x123, caption = "Summary of performance measures corresponding to optimal thresholds for the two $\\lambda$ and $\\mu$ values: \"Measure\" refers to a performance measure such as AUC or an operating point, AUC is the wAFROC area under curve, etc.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(2), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 

```

Table \@ref(tab:optim-op-point-cad-optim-table) summarizes the results of the optimizations. The first two rows compare the AUCs for $\lambda=10$ and $\lambda=1$ for the two values of $\mu$. The next row shows the operating point (NLF, LLF) for $\lambda = 10$ for the two values of $\mu$ and the final row shows the operating point for $\lambda = 1$ for the two values of $\mu$. The following trends are evident (in the following *optimal NLF* means NLF at the optimal operating point on the FROC, etc.).

* Area under curve increases with increasing $\mu$. Increasing the separation of the two unit variance normal distributions that determine the ratings of NLs and LLs leads to higher performance.
* Area under curve increases with *decreasing* $\lambda$. Decreasing the tendency of the observer to generate NLs leads to increasing performance.
* Increasing $\mu$ causes the optimal operating point to move up the FROC curve. 
* Decreasing $\lambda$ causes the optimal operating point to move up the FROC curve. 
* All of these observations can be summarized by the following: *as performance increases the CAD designer can afford to show more of the marks generated by the algorithm*. 

### Illustrative FROC curves {#optim-op-point-threshold-illustrations}


#### $\lambda = 10, \mu = 1$ {#optim-op-point-threshold-illustrations-10-1}

```{r optim-op-point-froc-10, fig.cap="Extended FROC plots: panel labeled 10-1 is for $\\lambda = 10$ and $\\mu = 1$, and that labeled 10-1.5 is for $\\lambda = 10$ and $\\mu = 1.5$. The blue line indicates the optimal operating point.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[1,1]], plotArr[[1,2]], nrow = 1, ncol = 2)
```             


* In order to show a fuller extent of the FROC curve it is necessary to *extend* the curves beyond the *optimal* operating point. This was done by setting $\zeta_1$ = $\zeta_{\text{max}} - 0.5$, which has the effect of letting the curve run a little bit further to the upper-right. 

* The *optimal* operating-point, corresponding to the vertical blue line, for the curve in Fig. \@ref(fig:optim-op-point-froc-10) labeled **10-1** is `r OpPtStr(optOpPt[1,1,1], optOpPt[1,2,1])` while the *extended* point, corresponding to the edge of the plot, is `r OpPtStr(OpPtExtended[1,1,1], OpPtExtended[1,2,1])`. The *highest* operating point, that reached when all marks are reported, is `r OpPtStr(OpPtMax[1,1,1], OpPtMax[1,2,1])`. This point lies about a factor 300 to the right of the displayed curve and about a factor of six higher along the y-axis. It vividly illustrates a low-performing FROC curve. Note the "expanded-view" scale factors, focusing on the region very near the origin: the x-axis runs from 0 to 0.03 while the y-axis runs from 0 to 0.1. Otherwise this curve would be almost indistinguishable from the x-axis. For large $\lambda$ and small $\mu$ performance is very low, in fact wAFROC AUC = `r sprintf ("%.3f", maxFomArr[1,1])` (note that we are using the wAFROC FOM, whose minimum possible value is 0, not 0.5). The optimal operating point of the algorithm is close to the origin. With such poor algorithm performance the sensible choice is to only show those marks that have, according to the algorithm, very high confidence level for being right (an operating point near the origin corresponds to a high value of $\zeta$). 

* Fig. \@ref(fig:optim-op-point-2plots) demonstrates visually the effect on wAFROC area under curve of showing very few marks (red dashed line - this line extends almost all the way to the origin as on this scale the short continuous section is not visible) as compared to showing more marks (blue solid plus dashed line). These plots are for $\lambda = 10$, $\mu = 1$ and $\zeta_1 = 3.25$ for the upper curve and $\zeta_1 = 1.5$ for the lower curve.


```{r, echo=FALSE}
x1 <- PlotRsmOperatingCharacteristics(mu = c(1, 1), lambda = c(10, 10), nu = c(1, 1), zeta1 = c(3.25, 1.5), lesDistr = lesDistr, relWeights = relWeights, legendPosition = "none")$wAFROC
```


```{r optim-op-point-2plots, fig.cap=" With a poor algorithm it pays to not show too many marks. Shown are wAFROC plots for $\\mu = 1$, $\\lambda = 10$ and $\\nu = 1$. The upper curve corresponds to $\\zeta_1 = 3.25$, the lower to $\\zeta_1 = 1.5$. By reporting fewer marks algorithm performance in the upper plot is visibly improved over that in the lower.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(x1, ncol = 1)
```


#### $\lambda = 10, \mu = 2$ {#optim-op-point-threshold-illustrations-10-2}


* In Fig. \@ref(fig:optim-op-point-froc-10) panel labeled **10-2**: the optimal operating point is `r OpPtStr(optOpPt[1,1,2], optOpPt[1,2,2])`. Given the higher value of $\mu$ the algorithm designer can show marks with lower confidence levels, corresponding to the optimal operating point moving up the FROC curve. The end-point of the extended curve is `r OpPtStr(OpPtExtended[1,1,2], OpPtExtended[1,2,2])`. The highest operating point, when all marks are reported, is `r OpPtStr(OpPtMax[1,1,2], OpPtMax[1,2,2])`. 


```{r optim-op-point-froc-01, fig.cap="Extended FROC plots: panel labeled 1-1 is for $\\lambda = 1$ and $\\mu = 1$ and that labeled 10-1.5 is for $\\lambda = 1$ and $\\mu = 1.5$. The blue line indicates the optimal operating point.", fig.show='hold', echo=FALSE, fig.height=3.5,  fig.pos='H'}
grid.arrange(plotArr[[2,1]], plotArr[[2,2]], ncol = 2)
```             


#### $\lambda = 1, \mu = 1$ {#optim-op-point-threshold-illustrations-1-1}

* In Fig. \@ref(fig:optim-op-point-froc-01) panel labeled **1-1**: The optimal operating point is `r OpPtStr(optOpPt[2,1,1], optOpPt[2,2,1])`. The end-point of the extended curve is `r OpPtStr(OpPtExtended[2,1,1], OpPtExtended[2,2,1])`. The highest operating point on the FROC is `r OpPtStr(OpPtMax[2,1,1], OpPtMax[2,2,1])`. 


#### $\lambda = 1, \mu = 2$ {#optim-op-point-threshold-illustrations-1-2}

* In Fig. \@ref(fig:optim-op-point-froc-01) panel labeled **1-2**: The optimal operating point is `r OpPtStr(optOpPt[2,1,2], optOpPt[2,2,2])`. The end-point of the extended curve is `r OpPtStr(OpPtExtended[2,1,2], OpPtExtended[2,2,2])`. The highest operating point on the FROC is  `r OpPtStr(OpPtMax[2,1,2], OpPtMax[2,2,2])`. 



### Applying the method {#optim-op-point-how-to-use-method}
* Assume that one has designed an algorithmic observer that has been optimized with respect to all other parameters except the reporting threshold and that with sufficiently low reporting threshold the algorithm reports *every* suspicious region it found. All that remains is to find the optimal reporting threshold. 

* The mark-rating pairs are entered into a `RJafroc` format Excel input file. 

* Read the data file -- `DfReadDataFile()` -- and convert it to an ROC dataset -- `DfFroc2Roc()`. 

* Fit the radiological search model (RSM) to the ROC dataset -- `FitRsmRoc()`. 

* This yields the parameters -- $\lambda, \mu, \nu$  -- needed to perform the calculations described in the embedded code of this chapter. 

* This determines the optimal reporting threshold $\zeta_{\text{max}}$. 

* Set the algorithm to only report marks with confidence levels exceeding $\zeta_{\text{max}}$.  



## Discussion {#optim-op-point-Discussion}



## References {#optim-op-point-references}
